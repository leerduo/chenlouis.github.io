
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>training for the thirteenth part | louis.chen</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="louis.chen">
    

    
    <meta name="description" content="本部分为第十三部分，主要内容一是处理View的相关事件，而是处理输入法的相关的api。其中处理View事件的部分包括：


检测常用的手势
追踪手势移动
Scroll手势动画
Scroller
处理多触摸手势
处理多触摸手势
管理ViewGroup中的触摸事件


而输入法处理相关的内容包括一下的部分：


指定输入法类型
指定输入法类型">
<meta property="og:type" content="article">
<meta property="og:title" content="training for the thirteenth part">
<meta property="og:url" content="http://chenfuduo.me/2015/07/02/training-for-the-thirteenth-part/index.html">
<meta property="og:site_name" content="louis.chen">
<meta property="og:description" content="本部分为第十三部分，主要内容一是处理View的相关事件，而是处理输入法的相关的api。其中处理View事件的部分包括：


检测常用的手势
追踪手势移动
Scroll手势动画
Scroller
处理多触摸手势
处理多触摸手势
管理ViewGroup中的触摸事件


而输入法处理相关的内容包括一下的部分：


指定输入法类型
指定输入法类型">
<meta property="og:image" content="http://1.infotravel.sinaapp.com/pic/24.gif">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="training for the thirteenth part">
<meta name="twitter:description" content="本部分为第十三部分，主要内容一是处理View的相关事件，而是处理输入法的相关的api。其中处理View事件的部分包括：


检测常用的手势
追踪手势移动
Scroll手势动画
Scroller
处理多触摸手势
处理多触摸手势
管理ViewGroup中的触摸事件


而输入法处理相关的内容包括一下的部分：


指定输入法类型
指定输入法类型">

    
    <link rel="alternative" href="/atom.xml" title="louis.chen" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="louis.chen" title="louis.chen"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="louis.chen">louis.chen</a></h1>
				<h2 class="blog-motto">纸上得来终觉浅,绝知此事要躬行。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/project">项目</a></li>
					
						<li><a href="/about">资源</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:chenfuduo.me">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/07/02/training-for-the-thirteenth-part/" title="training for the thirteenth part" itemprop="url">training for the thirteenth part</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="louis.chen" target="_blank" itemprop="author">louis.chen</a>
		
  <p class="article-time">
    <time datetime="2015-07-02T07:00:38.000Z" itemprop="datePublished"> 发表于 2015-07-02</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#使用触摸手势"><span class="toc-number">1.</span> <span class="toc-text">使用触摸手势</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#检测常用的手势"><span class="toc-number">1.1.</span> <span class="toc-text">检测常用的手势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Support_Library_中的类"><span class="toc-number">1.1.1.</span> <span class="toc-text">Support Library 中的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收集数据"><span class="toc-number">1.1.2.</span> <span class="toc-text">收集数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为Activity或View捕获触摸事件"><span class="toc-number">1.1.3.</span> <span class="toc-text">为Activity或View捕获触摸事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#捕获单个view的触摸事件"><span class="toc-number">1.1.4.</span> <span class="toc-text">捕获单个view的触摸事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检测手势"><span class="toc-number">1.1.5.</span> <span class="toc-text">检测手势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检测所有支持的手势"><span class="toc-number">1.1.6.</span> <span class="toc-text">检测所有支持的手势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检测部分支持的手势"><span class="toc-number">1.1.7.</span> <span class="toc-text">检测部分支持的手势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#追踪手势移动"><span class="toc-number">1.2.</span> <span class="toc-text">追踪手势移动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#追踪速度"><span class="toc-number">1.2.1.</span> <span class="toc-text">追踪速度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scroll手势动画"><span class="toc-number">1.3.</span> <span class="toc-text">Scroll手势动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#理解滚动术语"><span class="toc-number">1.3.1.</span> <span class="toc-text">理解滚动术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现基于触摸的滚动"><span class="toc-number">1.3.2.</span> <span class="toc-text">实现基于触摸的滚动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于scroller"><span class="toc-number">1.3.3.</span> <span class="toc-text">关于scroller</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理多触摸手势"><span class="toc-number">1.4.</span> <span class="toc-text">处理多触摸手势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#追踪多点"><span class="toc-number">1.4.1.</span> <span class="toc-text">追踪多点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取MotionEvent的动作"><span class="toc-number">1.4.2.</span> <span class="toc-text">获取MotionEvent的动作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拖拽与缩放"><span class="toc-number">1.5.</span> <span class="toc-text">拖拽与缩放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拖拽一个对象"><span class="toc-number">1.5.1.</span> <span class="toc-text">拖拽一个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过拖拽平移"><span class="toc-number">1.5.2.</span> <span class="toc-text">通过拖拽平移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用触摸手势进行缩放"><span class="toc-number">1.5.3.</span> <span class="toc-text">使用触摸手势进行缩放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本的缩放示例"><span class="toc-number">1.5.4.</span> <span class="toc-text">基本的缩放示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更加复杂的缩放示例"><span class="toc-number">1.5.5.</span> <span class="toc-text">更加复杂的缩放示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管理ViewGroup中的触摸事件"><span class="toc-number">1.6.</span> <span class="toc-text">管理ViewGroup中的触摸事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在ViewGroup中截获触摸事件"><span class="toc-number">1.6.1.</span> <span class="toc-text">在ViewGroup中截获触摸事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用ViewConfiguration的常量"><span class="toc-number">1.6.2.</span> <span class="toc-text">使用ViewConfiguration的常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展子view的可触摸区域"><span class="toc-number">1.6.3.</span> <span class="toc-text">扩展子view的可触摸区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#处理键盘输入"><span class="toc-number">2.</span> <span class="toc-text">处理键盘输入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#指定输入法类型"><span class="toc-number">2.1.</span> <span class="toc-text">指定输入法类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指定键盘类型"><span class="toc-number">2.1.1.</span> <span class="toc-text">指定键盘类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开启拼写建议和其它行为"><span class="toc-number">2.1.2.</span> <span class="toc-text">开启拼写建议和其它行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指定输入法的行为"><span class="toc-number">2.1.3.</span> <span class="toc-text">指定输入法的行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理输入法的显示"><span class="toc-number">2.2.</span> <span class="toc-text">处理输入法的显示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在Activity启动时显示输入法"><span class="toc-number">2.2.1.</span> <span class="toc-text">在Activity启动时显示输入法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#根据需要显示输入法"><span class="toc-number">2.2.2.</span> <span class="toc-text">根据需要显示输入法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指定_UI_的响应方式"><span class="toc-number">2.2.3.</span> <span class="toc-text">指定 UI 的响应方式</span></a></li></ol></li></ol></li></ol>
		
		</div>
		
		<p>本部分为第十三部分，主要内容一是处理View的相关事件，而是处理输入法的相关的api。其中处理View事件的部分包括：</p>
<blockquote>
<ul>
<li>检测常用的手势</li>
<li>追踪手势移动</li>
<li>Scroll手势动画</li>
<li>Scroller</li>
<li>处理多触摸手势</li>
<li>处理多触摸手势</li>
<li>管理ViewGroup中的触摸事件</li>
</ul>
</blockquote>
<p>而输入法处理相关的内容包括一下的部分：</p>
<blockquote>
<ul>
<li>指定输入法类型</li>
<li>指定输入法类型</li>
</ul>
</blockquote>
<a id="more"></a>
<h1 id="使用触摸手势">使用触摸手势</h1><p>本部分讲述，如何编写一个允许用户通过触摸手势进行交互的app。Android提供了各种各样的API，来帮助我们创建和检测手势。</p>
<p>尽管对于一些基本的操作来说，我们的app不应该依赖于触摸手势（因为某些情况下手势是不用的）。但为我们的app添加基于触摸的交互，将会大大地提高app的可用性和吸引力。</p>
<hr>
<h2 id="检测常用的手势">检测常用的手势</h2><p>当用户用一根或多根手指放在触摸屏上，并且应用把这样的触摸方式解释为特定的手势时，“触摸手势”就发生了。相应地，检测手势也就有以下两个阶段：</p>
<blockquote>
<ul>
<li>收集触摸事件的相关数据。</li>
<li>分析这些数据，看它们是否符合app所支持的手势的标准。</li>
</ul>
</blockquote>
<hr>
<h3 id="Support_Library_中的类">Support Library 中的类</h3><p>本部分示例程序使用了<code>GestureDetectorCompat</code>和<code>MotionEventCompat</code>类。这些类都是在 Support Library 中定义的。如果有可能的情况话，我们应该使用 Support Library 中的类，来为运行着Android1.6及以上版本系统的设备提供兼容性功能。需要注意的一点是，MotionEventCompat并不是MotionEvent的替代品，而是提供了一些静态工具类函数。我们可以把MotionEvent对象作为参数传递给这些工具类函数，来获得与触摸事件相关的动作(action)。</p>
<hr>
<h3 id="收集数据">收集数据</h3><p>当用户用一根或多根手指放在触摸屏上时，会触发 View 上用于接收触摸事件的 <code>onTouchEvent()</code> 回调函数。对于一系列连续的、最终会被识别为一种手势的触摸事件（位置、压力、大小、添加另一根手指等等），onTouchEvent()会被调用若干次。</p>
<p>当用户第一次触摸屏幕时，手势就开始了。其后系统会持续地追踪用户手指的位置，在用户手指全都离开屏幕时，手势结束。在整个交互期间，被分发给 onTouchEvent() 函数的 MotionEvent 对象，提供了每次交互的详细信息。我们的app可以使用 MotionEvent 提供的这些数据，来判断某种特定的手势是否发生了。</p>
<hr>
<h3 id="为Activity或View捕获触摸事件">为Activity或View捕获触摸事件</h3><p>为了捕获Activity或View中的触摸事件，我们可以重写onTouchEvent()回调函数。</p>
<p>接下来的代码段使用了<code>getActionMasked()</code>函数，来从 event 参数中抽取出用户执行的动作。它提供了一些原始的触摸数据，我们可以使用这些数据，来判断某个特定手势是否发生了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// This example shows an Activity, but you would use the same approach if</span></span><br><span class="line"><span class="comment">// you were subclassing a View.</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(action) &#123;</span><br><span class="line">                <span class="keyword">case</span> (MotionEvent.ACTION_DOWN) :</span><br><span class="line">                Log.d(DEBUG_TAG,<span class="string">"Action was DOWN"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (MotionEvent.ACTION_MOVE) :</span><br><span class="line">                Log.d(DEBUG_TAG,<span class="string">"Action was MOVE"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (MotionEvent.ACTION_UP) :</span><br><span class="line">                Log.d(DEBUG_TAG,<span class="string">"Action was UP"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (MotionEvent.ACTION_CANCEL) :</span><br><span class="line">                Log.d(DEBUG_TAG,<span class="string">"Action was CANCEL"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">case</span> (MotionEvent.ACTION_OUTSIDE) :</span><br><span class="line">                Log.d(DEBUG_TAG,<span class="string">"Movement occurred outside bounds "</span> +</span><br><span class="line">                        <span class="string">"of current screen element"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们可以对这些事件做些自己的处理，以判断某个手势是否出现了。这种是针对自定义手势，我们所需要进行的处理。然而，如果我们的app仅仅需要一些常见的手势，如双击，长按，快速滑动（fling）等，那么我们可以使用<code>GestureDetector</code>类来完成。 GestureDetector可以让我们简单地检测常见手势，并且无需自行处理单个触摸事件。相关内容将会在下面的检测手势中讨论。</p>
<hr>
<h3 id="捕获单个view的触摸事件">捕获单个view的触摸事件</h3><p><strong>作为onTouchEvent()的一种替换方式，我们也可以使用 setOnTouchListener() 函数</strong>，来把 View.OnTouchListener 关联到任意的View上。这样可以在不继承已有的 View 的情况下，也能监听触摸事件。比如:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View myView = findViewById(R.id.my_view);</span><br><span class="line">myView.setOnTouchListener(<span class="keyword">new</span> OnTouchListener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... Respond to touch events</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>创建listener对象时，注意 ACTION_DOWN 事件返回 false 的情况。<strong>如果返回 false，会让listener对象接收不到后续的ACTION_MOVE、ACTION_UP等系列事件。</strong>这是因为ACTION_DOWN事件是所有触摸事件的开端。</p>
<p>如果我们正在写一个自定义View，我们也可以像上面描述的那样重写onTouchEvent()函数。</p>
<hr>
<h3 id="检测手势">检测手势</h3><p>Android提供了<code>GestureDetector</code>类来检测常用的手势。它所支持的手势包括<code>onDown()</code>、<code>onLongPress()</code>、<code>onFling()</code> 等。我们可以把GestureDetector和上面描述的onTouchEvent()函数结合在一起使用。</p>
<hr>
<h3 id="检测所有支持的手势">检测所有支持的手势</h3><p>当我们实例化一个<code>GestureDetectorCompat</code>对象时，需要一个实现了<code>GestureDetector.OnGestureListener</code>接口的类作为参数。当某个特定的触摸事件发生时，<code>GestureDetector.OnGestureListener</code>就会通知用户。<strong>为了让我们的GestureDetector对象能到接收到触摸事件，我们需要重写 View 或 Activity 的 onTouchEvent() 函数，并且把所有捕获到的事件传递给 detector 实例。</strong>(详细见下面的代码)</p>
<p><strong>接下来的代码段中，on<touchevent> 型的函数的返回值是 true，意味着我们已经处理完这个触摸事件了。</touchevent></strong>如果返回 false，则会把事件沿view栈传递，直到触摸事件被成功地处理了。</p>
<p>运行下面的代码段，来了解当我们与触摸屏交互时，动作（action）是如何触发的，以及每个触摸事件MotionEvent中的内容。我们也会意识到，一个简单的交互会产生多少的数据。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span></span><br><span class="line">        <span class="title">GestureDetector</span>.<span class="title">OnGestureListener</span>,</span><br><span class="line">        <span class="title">GestureDetector</span>.<span class="title">OnDoubleTapListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEBUG_TAG = <span class="string">"Gestures"</span>;</span><br><span class="line">    <span class="keyword">private</span> GestureDetectorCompat mDetector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called when the activity is first created.</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// Instantiate the gesture detector with the</span></span><br><span class="line">        <span class="comment">// application context and an implementation of</span></span><br><span class="line">        <span class="comment">// GestureDetector.OnGestureListener</span></span><br><span class="line">        mDetector = <span class="keyword">new</span> GestureDetectorCompat(<span class="keyword">this</span>,<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// Set the gesture detector as the double tap</span></span><br><span class="line">        <span class="comment">// listener.</span></span><br><span class="line">        mDetector.setOnDoubleTapListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mDetector.onTouchEvent(event);</span><br><span class="line">        <span class="comment">// Be sure to call the superclass implementation</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.d(DEBUG_TAG,<span class="string">"onDown: "</span> + event.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent event1, MotionEvent event2,</span><br><span class="line">            <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line">        Log.d(DEBUG_TAG, <span class="string">"onFling: "</span> + event1.toString()+event2.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.d(DEBUG_TAG, <span class="string">"onLongPress: "</span> + event.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> distanceX,</span><br><span class="line">            <span class="keyword">float</span> distanceY)</span> </span>&#123;</span><br><span class="line">        Log.d(DEBUG_TAG, <span class="string">"onScroll: "</span> + e1.toString()+e2.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowPress</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.d(DEBUG_TAG, <span class="string">"onShowPress: "</span> + event.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.d(DEBUG_TAG, <span class="string">"onSingleTapUp: "</span> + event.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDoubleTap</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.d(DEBUG_TAG, <span class="string">"onDoubleTap: "</span> + event.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDoubleTapEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.d(DEBUG_TAG, <span class="string">"onDoubleTapEvent: "</span> + event.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapConfirmed</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        Log.d(DEBUG_TAG, <span class="string">"onSingleTapConfirmed: "</span> + event.toString());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="检测部分支持的手势">检测部分支持的手势</h3><p>如果我们只想处理几种手势，那么可以选择继承 <code>GestureDetector.SimpleOnGestureListener</code> 类，而不是实现 <code>GestureDetector.OnGestureListener</code> 接口。</p>
<p><code>GestureDetector.SimpleOnGestureListener</code> 类<strong>实现了所有的 on<touchevent> 型函数，其中，这些函数都返回 false。</touchevent></strong>因此，我们可以仅仅重写我们需要的函数。比如，下面的代码段中，创建了一个继承自 GestureDetector.SimpleOnGestureListener 的类，并重写了 onFling() 和 onDown() 函数。</p>
<p>无论我们是否使用GestureDetector.OnGestureListener类，<strong>最好都实现 onDown() 函数并且返回 true。这是因为所有的手势都是由 onDown() 消息开始的。</strong>如果让 onDown() 函数返回 false，就像GestureDetector.SimpleOnGestureListener类中默认实现的那样，系统会假定我们想忽略剩余的手势，GestureDetector.OnGestureListener中的其他函数也就永远不会被调用。这可能会导致我们的app出现意想不到的问题。仅仅当我们真的想忽略全部手势时，我们才应该让 onDown() 函数返回 false。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GestureDetectorCompat mDetector;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mDetector = <span class="keyword">new</span> GestureDetectorCompat(<span class="keyword">this</span>, <span class="keyword">new</span> MyGestureListener());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mDetector.onTouchEvent(event);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyGestureListener</span> <span class="keyword">extends</span> <span class="title">GestureDetector</span>.<span class="title">SimpleOnGestureListener</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEBUG_TAG = <span class="string">"Gestures"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">            Log.d(DEBUG_TAG,<span class="string">"onDown: "</span> + event.toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent event1, MotionEvent event2,</span><br><span class="line">                <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line">            Log.d(DEBUG_TAG, <span class="string">"onFling: "</span> + event1.toString()+event2.toString());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="追踪手势移动">追踪手势移动</h2><p>本部分讲述如何追踪手势移动。</p>
<p><strong>每当当前的触摸位置、压力、大小发生变化时，ACTION_MOVE事件都会触发onTouchEvent()函数。</strong>正如检测常用的手势中描述的那样，<strong>触摸事件全部都记录在onTouchEvent()函数的MotionEvent参数中。
</strong><br>因为基于手指的触摸的交互方式并不总是非常精确，所以<strong>检测触摸事件更多的是基于手势移动</strong>，而非简单地基于触摸。为了帮助app区分基于移动的手势（如滑动）和非移动手势（如简单地点击），Android引入了“touch slop”的概念。<strong>Touch slop是指，在被识别为基于移动的手势前，用户触摸可移动的那一段像素距离。</strong></p>
<p>根据应用的需求，有多种追踪手势移动的方式可以选择。比如：</p>
<blockquote>
<ul>
<li>追踪手指的起始和终止位置（比如，把屏幕上的对象从A点移动到B点）</li>
<li>根据x、y轴坐标，追踪手指移动的方向。</li>
<li>追踪历史状态。我们可以通过调用MotionEvent的<code>getHistorySize()</code>方法，来获得一个手势的历史尺寸。我们可以通过移动事件的<code>getHistorical&lt;Value&gt;</code>系列函数，来获得事件之前的位置、尺寸、时间以及按压力(pressures)。当我们需要绘制用户手指痕迹时，历史状态非常有用，比如触摸绘图。查看MotionEvent来了解更多细节。</li>
<li>追踪手指在触摸屏上滑过的速度。</li>
</ul>
</blockquote>
<hr>
<h3 id="追踪速度">追踪速度</h3><p>我们可以简单地用基于距离，或(和)基于手指移动方向的移动手势。但是速度经常也是追踪手势特性的一个决定性因素，甚至是判断一个手势是否发生的依据。为了让计算速度更容易，Android提供了<code>VelocityTracker</code>类以及Support Library中的<code>VelocityTrackerCompat</code>类。<code>VelocityTracker类</code>可以帮助我们追踪触摸事件中的速度因素。如果速度是手势的一个判断标准，比如快速滑动(fling)，那么这些类是很有用的。</p>
<p>下面是一个简单的例子，说明了VelocityTracker中API函数的用处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = MainActivity.class.getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView tv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> GestureDetector mDetector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> VelocityTracker mVelocityTracker = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mDetector = <span class="keyword">new</span> GestureDetector(<span class="keyword">this</span>,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        mDetector.setOnDoubleTapListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        tv = (TextView) findViewById(R.id.tv);</span><br><span class="line">        tv.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> index = event.getActionIndex();</span><br><span class="line">                <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(event);</span><br><span class="line">                <span class="keyword">int</span> pointerId = event.getPointerId(index);</span><br><span class="line">                <span class="keyword">switch</span> (action)&#123;</span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                        Log.e(TAG,<span class="string">"ACTION_DOWN"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (mVelocityTracker == <span class="keyword">null</span>)&#123;</span><br><span class="line">                            <span class="comment">// Retrieve a new VelocityTracker object to watch the velocity of a motion.</span></span><br><span class="line">                            mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">// Reset the velocity tracker back to its initial state.</span></span><br><span class="line">                            mVelocityTracker.clear();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// Add a user's movement to the tracker.</span></span><br><span class="line">                        mVelocityTracker.addMovement(event);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                        Log.e(TAG,<span class="string">"ACTION_UP"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                        Log.e(TAG,<span class="string">"ACTION_MOVE"</span>);</span><br><span class="line">                        mVelocityTracker.addMovement(event);</span><br><span class="line">                        <span class="comment">// When you want to determine the velocity, call</span></span><br><span class="line">                        <span class="comment">// computeCurrentVelocity(). Then call getXVelocity()</span></span><br><span class="line">                        <span class="comment">// and getYVelocity() to retrieve the velocity for each pointer ID.</span></span><br><span class="line">                        mVelocityTracker.computeCurrentVelocity(<span class="number">1000</span>);</span><br><span class="line">                        Log.d(TAG,<span class="string">"X velocity: "</span> + VelocityTrackerCompat.getXVelocity(mVelocityTracker,pointerId));</span><br><span class="line">                        Log.d(TAG,<span class="string">"Y velocity: "</span> + VelocityTrackerCompat.getYVelocity(mVelocityTracker, pointerId));</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">                        Log.e(TAG,<span class="string">"ACTION_CANCEL"</span>);</span><br><span class="line">                        <span class="comment">// Return a VelocityTracker object back to be re-used by others.</span></span><br><span class="line">                        mVelocityTracker.recycle();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> MotionEvent.ACTION_OUTSIDE:</span><br><span class="line">                        Log.e(TAG,<span class="string">"ACTION_OUTSIDE"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，我们应该在<code>ACTION_MOVE</code>事件中计算速度，而不是在ACTION_UP事件后计算速度。<strong>在ACTION_UP事件之后，计算x、y方向上的速度都会是0。</strong></p>
</blockquote>
<hr>
<h2 id="Scroll手势动画">Scroll手势动画</h2><p>在Android中，通常使用<code>ScrollView</code>类来实现滚动（scroll）。任何可能超过父类边界的布局，都应该嵌套在ScrollView中，来提供一个由系统框架管理的可滚动的view。仅在某些特殊情形下，我们才要实现一个自定义scroller。本部分就描述了这样一个情形：<strong>使用 scrollers 显示滚动效果，以响应触摸手势。</strong></p>
<p>为了收集数据来产生滚动动画，以响应一个触摸事件，我们可以使用scrollers<code>（Scroller或者OverScroller）</code>。这两个类很相似，但<code>OverScroller</code>有一些函数，能在平移或快速滑动手势后，向用户指出已经达到内容的边缘。</p>
<blockquote>
<p>Note: 比起<code>Scroller</code>类，更推荐使用<code>OverScroller</code>类来产生滚动动画。OverScroller类为老设备提供了很好的向后兼容性。 另外需要注意的是，仅当我们要自己实现滚动时，才需要使用scrollers。如果我们把布局嵌套在ScrollView和HorizontalScrollView中，它们会帮我们把这些做好。</p>
</blockquote>
<p><strong>通过使用平台标准的滚动物理因素（摩擦、速度等），scroller被用来随着时间的推移产生滚动动画。</strong>实际上，<code>scroller本身不会绘制任何东西</code>。<strong>Scrollers只是随着时间的推移，追踪滚动的偏移量，但它们不会自动地把这些位置应用到view上。应该按一定频率，获取并应用这些新的坐标值，来让滚动动画更加顺滑。</strong></p>
<hr>
<h3 id="理解滚动术语">理解滚动术语</h3><p>在Android中，“Scrolling”这个词根据不同情景有着不同的含义。</p>
<p>滚动（Scrolling）是指移动视窗（viewport）（指你正在看的内容所在的‘窗口’）的一般过程。当在x轴和y轴方向同时滚动时，就叫做平移（panning）。示例程序提供的 InteractiveChart 类，展示了两种不同类型的滚动，<code>拖拽</code>与<code>快速滑动</code>。(dragging and flinging)示例程序源代码详见后面的源代码部分。</p>
<blockquote>
<ul>
<li>拖拽（dragging）是滚动的一种类型，当用户在触摸屏上拖动手指时发生。简单的拖拽一般可以通过重写 <code>GestureDetector.OnGestureListener</code> 的 <code>onScroll()</code> 来实现。关于拖拽的更多讨论，下面介绍。</li>
<li>快速滑动（fling）这种类型的滚动，在用户快速拖拽后，抬起手指时发生。<strong>当用户抬起手指后，通常想继续保持滚动（移动视窗），但会一直减速直到视窗停止移动。</strong>通过重写<code>GestureDetector.OnGestureListener</code>的<code>onFling()</code>函数，使用<code>scroller</code>对象，可实现快速滑动。这种用法也就是本节课程的主题。</li>
</ul>
</blockquote>
<p>scroller对象通常会与快速滑动手势结合起来使用。但在任何我们想让UI展示滚动动画，以响应触摸事件的场景，都可以用scroller对象来实现。比如，我们可以重写onTouchEvent()函数，直接处理触摸事件，并且产生一个滚动效果或“页面对齐”动画(snapping to page)，来响应这些触摸事件。</p>
<hr>
<h3 id="实现基于触摸的滚动">实现基于触摸的滚动</h3><p>本部分讲述如何使用<code>scroller。</code>（training的例子代码太多了，下面有自己写的代码，再下面介绍）下面的代码段来自 <code>InteractiveChart</code> 示例。它使用<code>GestureDetector</code>，并且重写了<code>GestureDetector.SimpleOnGestureListener</code>的 <code>onFling()</code> 函数。它使用<code>OverScroller</code>追踪快速滑动（fling）手势。快速滑动手势后，如果用户到达内容边缘，应用会显示一种发光效果。</p>
<blockquote>
<p>Note: <code>InteractiveChart</code>示例程序展示了一个可缩放、平移、滑动的表格。在接下来的代码段中，mContentRect表示view中的一块矩形坐标区域，该区域将被用来绘制表格。在任意给定的时间点，表格中某一部分会被绘制在这个区域内。mCurrentViewport表示当前在屏幕上可见的那一部分表格。因为像素偏移量通常当作整型处理，所以mContentRect是Rect类型的。因为图表的区域范围是数值型/浮点型值，所以mCurrentViewport是RectF类型。</p>
</blockquote>
<p>代码段的第一部分展示了onFling()函数的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The current viewport. This rectangle represents the currently visible </span></span><br><span class="line"><span class="comment">// chart domain and range. The viewport is the part of the app that the</span></span><br><span class="line"><span class="comment">// user manipulates via touch gestures.</span></span><br><span class="line"><span class="keyword">private</span> RectF mCurrentViewport =</span><br><span class="line">        <span class="keyword">new</span> RectF(AXIS_X_MIN, AXIS_Y_MIN, AXIS_X_MAX, AXIS_Y_MAX);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The current destination rectangle (in pixel coordinates) into which the</span></span><br><span class="line"><span class="comment">// chart data should be drawn.</span></span><br><span class="line"><span class="keyword">private</span> Rect mContentRect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> OverScroller mScroller;</span><br><span class="line"><span class="keyword">private</span> RectF mScrollerStartViewport;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> GestureDetector.SimpleOnGestureListener mGestureListener</span><br><span class="line">        = <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Initiates the decay phase of any active edge effects.</span></span><br><span class="line">        releaseEdgeEffects();</span><br><span class="line">        mScrollerStartViewport.set(mCurrentViewport);</span><br><span class="line">        <span class="comment">// Aborts any active scroll animations and invalidates.</span></span><br><span class="line">        mScroller.forceFinished(<span class="keyword">true</span>);</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(InteractiveLineGraphView.<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2,</span><br><span class="line">            <span class="keyword">float</span> velocityX, <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line">        fling((<span class="keyword">int</span>) -velocityX, (<span class="keyword">int</span>) -velocityY);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fling</span><span class="params">(<span class="keyword">int</span> velocityX, <span class="keyword">int</span> velocityY)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Initiates the decay phase of any active edge effects.</span></span><br><span class="line">    releaseEdgeEffects();</span><br><span class="line">    <span class="comment">// Flings use math in pixels (as opposed to math based on the viewport).</span></span><br><span class="line">    Point surfaceSize = computeScrollSurfaceSize();</span><br><span class="line">    mScrollerStartViewport.set(mCurrentViewport);</span><br><span class="line">    <span class="keyword">int</span> startX = (<span class="keyword">int</span>) (surfaceSize.x * (mScrollerStartViewport.left -</span><br><span class="line">            AXIS_X_MIN) / (</span><br><span class="line">            AXIS_X_MAX - AXIS_X_MIN));</span><br><span class="line">    <span class="keyword">int</span> startY = (<span class="keyword">int</span>) (surfaceSize.y * (AXIS_Y_MAX -</span><br><span class="line">            mScrollerStartViewport.bottom) / (</span><br><span class="line">            AXIS_Y_MAX - AXIS_Y_MIN));</span><br><span class="line">    <span class="comment">// Before flinging, aborts the current animation.</span></span><br><span class="line">    mScroller.forceFinished(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// Begins the animation</span></span><br><span class="line">    mScroller.fling(</span><br><span class="line">            <span class="comment">// Current scroll position</span></span><br><span class="line">            startX,</span><br><span class="line">            startY,</span><br><span class="line">            velocityX,</span><br><span class="line">            velocityY,</span><br><span class="line">            <span class="comment">/*</span><br><span class="line">             * Minimum and maximum scroll positions. The minimum scroll</span><br><span class="line">             * position is generally zero and the maximum scroll position</span><br><span class="line">             * is generally the content size less the screen size. So if the</span><br><span class="line">             * content width is 1000 pixels and the screen width is 200</span><br><span class="line">             * pixels, the maximum scroll offset should be 800 pixels.</span><br><span class="line">             */</span></span><br><span class="line">            <span class="number">0</span>, surfaceSize.x - mContentRect.width(),</span><br><span class="line">            <span class="number">0</span>, surfaceSize.y - mContentRect.height(),</span><br><span class="line">            <span class="comment">// The edges of the content. This comes into play when using</span></span><br><span class="line">            <span class="comment">// the EdgeEffect class to draw "glow" overlays.</span></span><br><span class="line">            mContentRect.width() / <span class="number">2</span>,</span><br><span class="line">            mContentRect.height() / <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// Invalidates to trigger computeScroll()</span></span><br><span class="line">    ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>onFling()</code>函数调用<code>postInvalidateOnAnimation()</code>时，它会触发<code>computeScroll()</code>来更新x、y的值。通常一个子view用scroller对象来产生滚动动画时会这样做，就像本例一样。</p>
<p>大多数views直接通过<code>scrollTo()</code>函数传递scroller对象的x、y坐标值。接下来的computeScroll()函数的实现中采用了一种不同的方式。它调用<code>computeScrollOffset()</code>函数来获得当前位置的x、y值。当满足边缘显示发光效果的条件时（图表已被放大显示，x或y值超过边界，并且app当前没有显示overscroll），这段代码会设置overscroll发光效果，并调用<code>postInvalidateOnAnimation()</code>函数来让view失效重绘：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Edge effect / overscroll tracking objects.</span></span><br><span class="line"><span class="keyword">private</span> EdgeEffectCompat mEdgeEffectTop;</span><br><span class="line"><span class="keyword">private</span> EdgeEffectCompat mEdgeEffectBottom;</span><br><span class="line"><span class="keyword">private</span> EdgeEffectCompat mEdgeEffectLeft;</span><br><span class="line"><span class="keyword">private</span> EdgeEffectCompat mEdgeEffectRight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mEdgeEffectTopActive;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mEdgeEffectBottomActive;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mEdgeEffectLeftActive;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mEdgeEffectRightActive;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.computeScroll();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> needsInvalidate = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The scroller isn't finished, meaning a fling or programmatic pan</span></span><br><span class="line">    <span class="comment">// operation is currently active.</span></span><br><span class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">        Point surfaceSize = computeScrollSurfaceSize();</span><br><span class="line">        <span class="keyword">int</span> currX = mScroller.getCurrX();</span><br><span class="line">        <span class="keyword">int</span> currY = mScroller.getCurrY();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> canScrollX = (mCurrentViewport.left &gt; AXIS_X_MIN</span><br><span class="line">                || mCurrentViewport.right &lt; AXIS_X_MAX);</span><br><span class="line">        <span class="keyword">boolean</span> canScrollY = (mCurrentViewport.top &gt; AXIS_Y_MIN</span><br><span class="line">                || mCurrentViewport.bottom &lt; AXIS_Y_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * If you are zoomed in and currX or currY is</span><br><span class="line">         * outside of bounds and you're not already</span><br><span class="line">         * showing overscroll, then render the overscroll</span><br><span class="line">         * glow edge effect.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">if</span> (canScrollX</span><br><span class="line">                &amp;&amp; currX &lt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; mEdgeEffectLeft.isFinished()</span><br><span class="line">                &amp;&amp; !mEdgeEffectLeftActive) &#123;</span><br><span class="line">            mEdgeEffectLeft.onAbsorb((<span class="keyword">int</span>)</span><br><span class="line">                    OverScrollerCompat.getCurrVelocity(mScroller));</span><br><span class="line">            mEdgeEffectLeftActive = <span class="keyword">true</span>;</span><br><span class="line">            needsInvalidate = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(canScrollX</span><br><span class="line">                &amp;&amp; currX &gt; (surfaceSize.x - mContentRect.width()</span>)</span><br><span class="line">                &amp;&amp; mEdgeEffectRight.<span class="title">isFinished</span><span class="params">()</span></span><br><span class="line">                &amp;&amp; !mEdgeEffectRightActive) </span>&#123;</span><br><span class="line">            mEdgeEffectRight.onAbsorb((<span class="keyword">int</span>)</span><br><span class="line">                    OverScrollerCompat.getCurrVelocity(mScroller));</span><br><span class="line">            mEdgeEffectRightActive = <span class="keyword">true</span>;</span><br><span class="line">            needsInvalidate = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (canScrollY</span><br><span class="line">                &amp;&amp; currY &lt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; mEdgeEffectTop.isFinished()</span><br><span class="line">                &amp;&amp; !mEdgeEffectTopActive) &#123;</span><br><span class="line">            mEdgeEffectTop.onAbsorb((<span class="keyword">int</span>)</span><br><span class="line">                    OverScrollerCompat.getCurrVelocity(mScroller));</span><br><span class="line">            mEdgeEffectTopActive = <span class="keyword">true</span>;</span><br><span class="line">            needsInvalidate = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(canScrollY</span><br><span class="line">                &amp;&amp; currY &gt; (surfaceSize.y - mContentRect.height()</span>)</span><br><span class="line">                &amp;&amp; mEdgeEffectBottom.<span class="title">isFinished</span><span class="params">()</span></span><br><span class="line">                &amp;&amp; !mEdgeEffectBottomActive) </span>&#123;</span><br><span class="line">            mEdgeEffectBottom.onAbsorb((<span class="keyword">int</span>)</span><br><span class="line">                    OverScrollerCompat.getCurrVelocity(mScroller));</span><br><span class="line">            mEdgeEffectBottomActive = <span class="keyword">true</span>;</span><br><span class="line">            needsInvalidate = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这是缩放部分的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Custom object that is functionally similar to Scroller</span></span><br><span class="line">Zoomer mZoomer;</span><br><span class="line"><span class="keyword">private</span> PointF mZoomFocalPoint = <span class="keyword">new</span> PointF();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// If a zoom is in progress (either programmatically or via double</span></span><br><span class="line"><span class="comment">// touch), performs the zoom.</span></span><br><span class="line"><span class="keyword">if</span> (mZoomer.computeZoom()) &#123;</span><br><span class="line">    <span class="keyword">float</span> newWidth = (<span class="number">1f</span> - mZoomer.getCurrZoom()) *</span><br><span class="line">            mScrollerStartViewport.width();</span><br><span class="line">    <span class="keyword">float</span> newHeight = (<span class="number">1f</span> - mZoomer.getCurrZoom()) *</span><br><span class="line">            mScrollerStartViewport.height();</span><br><span class="line">    <span class="keyword">float</span> pointWithinViewportX = (mZoomFocalPoint.x -</span><br><span class="line">            mScrollerStartViewport.left)</span><br><span class="line">            / mScrollerStartViewport.width();</span><br><span class="line">    <span class="keyword">float</span> pointWithinViewportY = (mZoomFocalPoint.y -</span><br><span class="line">            mScrollerStartViewport.top)</span><br><span class="line">            / mScrollerStartViewport.height();</span><br><span class="line">    mCurrentViewport.set(</span><br><span class="line">            mZoomFocalPoint.x - newWidth * pointWithinViewportX,</span><br><span class="line">            mZoomFocalPoint.y - newHeight * pointWithinViewportY,</span><br><span class="line">            mZoomFocalPoint.x + newWidth * (<span class="number">1</span> - pointWithinViewportX),</span><br><span class="line">            mZoomFocalPoint.y + newHeight * (<span class="number">1</span> - pointWithinViewportY));</span><br><span class="line">    constrainViewport();</span><br><span class="line">    needsInvalidate = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsInvalidate) &#123;</span><br><span class="line">    ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是上面代码段中调用过的<code>computeScrollSurfaceSize()</code>函数。它会以像素为单位计算当前可滚动的尺寸。举例来说，如果整个图表区域都是可见的，它的值就简单地等于mContentRect的大小。如果图表在两个方向上都放大到200%，此函数返回的尺寸在水平、垂直方向上都会大两倍。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Point <span class="title">computeScrollSurfaceSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Point(</span><br><span class="line">            (<span class="keyword">int</span>) (mContentRect.width() * (AXIS_X_MAX - AXIS_X_MIN)</span><br><span class="line">                    / mCurrentViewport.width()),</span><br><span class="line">            (<span class="keyword">int</span>) (mContentRect.height() * (AXIS_Y_MAX - AXIS_Y_MIN)</span><br><span class="line">                    / mCurrentViewport.height()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于scroller用法的另一个示例，可查看ViewPager类的源代码。它用滚动来响应快速滑动（fling），并且使用滚动来实现“页面对齐”(snapping to page)动画。</p>
<hr>
<h3 id="关于scroller">关于scroller</h3><p><code>Scroller</code>是Android中View平滑移动的一个辅助类，对于刚接触Scroller的人群来说它可能难以理解：</p>
<blockquote>
<ul>
<li>它是怎样滑动View的（如何与View关联的）？</li>
<li>又是谁触发了它？</li>
</ul>
</blockquote>
<p>其实要分析这两个问题，主要还得从View的绘制流程开始分析：<br>关于View的绘制流程，网上资料众多，基本上相差无几，这里就不再阐述，下面提取下解析Scroller功能的必要的几个View的绘制方法：</p>
<p><strong>scrllTo()/scrollBy() —-&gt; invalidate()/postInvalidate() —-&gt; computeScroll();</strong>（这个流程我们可以分析源码得到）。<strong>scrllTo()/scrollBy()是view移动的两个方法；它会更新View的新的坐标点，然后调用invalidate/postInvalidate方法刷新view; 滑动完成后再调用computeScroll（）方法；computeScroll（）是View.java的一个空的方法，需要由我们去实现处理。</strong></p>
<p>根据上面的流程我们想想，当在computeScroll()方法中调用scrollTo/scrollBy的时候，会发生什么？很简单，这样就会达成一个死循环，在同一个位置不断的刷新View,只是由于系统缓存与一些优化机制，我们看不出来它在刷新而已！</p>
<p>再当我们在computeScroll()方法中调用scrollTo/scrollBy的时候，同时不断的改变Y坐标的值又会发生什么？跟上面一样，会死循环刷新View，只是由于Y坐标不断的在变化，导致了View根据Y坐标变化规律上下移动，这样一来，如果Y坐标的变化是有规律的，是慢慢向下移动的，那这就达到了我们今天要研究的效果——平滑移动了；而这里要谈的Scroller就是这样一个工具类，给我们提供有规律变化的坐标的工具类；原来平滑移动如此easy，那么与其说Scroller是Android中View平滑移动的一个辅助类，不如直接说Scroller是一个计算坐标的工具类。其实Scroller与View的滑动是没有关系的，它只是计算在动画执行某个时间所在的某个位置的坐标，这样就形成了坐标路线，再view根据坐标路线循环invalidate在界上新显示，就形成了我们看到的平滑移动了。</p>
<p>知道了Scroller的工作原理，下面根据源码分析一下Scroller类常用的几个方法：</p>
<ul>
<li>startScroll（）方法：<br>源码：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;  </span><br><span class="line">    mMode = SCROLL_MODE;  </span><br><span class="line">    mFinished = <span class="keyword">false</span>;  </span><br><span class="line">    mDuration = duration;  </span><br><span class="line">    mStartTime = AnimationUtils.currentAnimationTimeMillis();  </span><br><span class="line">    mStartX = startX;  </span><br><span class="line">    mStartY = startY;  </span><br><span class="line">    mFinalX = startX + dx;  </span><br><span class="line">    mFinalY = startY + dy;  </span><br><span class="line">    mDeltaX = dx;  </span><br><span class="line">    mDeltaY = dy;  </span><br><span class="line">    mDurationReciprocal = <span class="number">1.0f</span> / (<span class="keyword">float</span>) mDuration;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>仅仅是设置了一下动画开始时间，起始坐标，终点坐标、时间倒数（仅仅是方便计算而已）等变量而已；其实这样我们的动画可以说已经开始了，只是没有根据坐标绘制到界面上而已；因为它这里保存了开始时间，当平滑开始的时候，Scroller就可以根据滑动的时间差来计算当前坐标应该处的位置，View根据坐标invalidate就可以滑动了；</p>
<p>当然这里影响到坐标计算的还有一个就是加速器，在重载的构造方法方法 public Scroller(Context context, Interpolator interpolator) 里面有详述：这里我们也可以自定义自己的加速器，具体原理与如何自定义这里就不阐述了；</p>
<ul>
<li>computeScrollOffset（）方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (mFinished) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> timePassed = (<span class="keyword">int</span>)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (timePassed &lt; mDuration) &#123;  </span><br><span class="line">        <span class="keyword">switch</span> (mMode) &#123;  </span><br><span class="line">        <span class="keyword">case</span> SCROLL_MODE:  </span><br><span class="line">            <span class="keyword">float</span> x = timePassed * mDurationReciprocal;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (mInterpolator == <span class="keyword">null</span>)  </span><br><span class="line">                x = viscousFluid(x);   </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                x = mInterpolator.getInterpolation(x);  </span><br><span class="line">  </span><br><span class="line">            mCurrX = mStartX + Math.round(x * mDeltaX);  </span><br><span class="line">            mCurrY = mStartY + Math.round(x * mDeltaY);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> FLING_MODE:  </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> t = (<span class="keyword">float</span>) timePassed / mDuration;  </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = (<span class="keyword">int</span>) (NB_SAMPLES * t);  </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> t_inf = (<span class="keyword">float</span>) index / NB_SAMPLES;  </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> t_sup = (<span class="keyword">float</span>) (index + <span class="number">1</span>) / NB_SAMPLES;  </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> d_inf = SPLINE[index];  </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> d_sup = SPLINE[index + <span class="number">1</span>];  </span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> distanceCoef = d_inf + (t - t_inf) / (t_sup - t_inf) * (d_sup - d_inf);  </span><br><span class="line">              </span><br><span class="line">            mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));  </span><br><span class="line">            <span class="comment">// Pin to mMinX &lt;= mCurrX &lt;= mMaxX  </span></span><br><span class="line">            mCurrX = Math.min(mCurrX, mMaxX);  </span><br><span class="line">            mCurrX = Math.max(mCurrX, mMinX);  </span><br><span class="line">              </span><br><span class="line">            mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));  </span><br><span class="line">            <span class="comment">// Pin to mMinY &lt;= mCurrY &lt;= mMaxY  </span></span><br><span class="line">            mCurrY = Math.min(mCurrY, mMaxY);  </span><br><span class="line">            mCurrY = Math.max(mCurrY, mMinY);  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123;  </span><br><span class="line">                mFinished = <span class="keyword">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        mCurrX = mFinalX;  </span><br><span class="line">        mCurrY = mFinalY;  </span><br><span class="line">        mFinished = <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>看代码主要当平滑没有完成的情况下，计算出当前滑动的坐标位置，如果平滑完成了，就不需要计算了；这里有一个<code>SCROLL_MODE</code>和<code>FLING_MODEL</code>两种滑动模式，这里是<code>SCROLL_MODE</code>手动拖动平滑模式，<code>FLING_MODEL</code>是由于手指滑动速率来判断惯性滑动。一般这个方法执行完成之后，根据返回值判断是否需要invalidate/postinvalidate，再根据Scroller计算好的坐标值，View将scrollTo/scrollBy到新的坐标位置；</p>
<ul>
<li>fling（）方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fling</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> velocityX, <span class="keyword">int</span> velocityY,  </span><br><span class="line">        <span class="keyword">int</span> minX, <span class="keyword">int</span> maxX, <span class="keyword">int</span> minY, <span class="keyword">int</span> maxY)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// Continue a scroll or fling in progress  </span></span><br><span class="line">    <span class="keyword">if</span> (mFlywheel &amp;&amp; !mFinished) &#123;  </span><br><span class="line">        <span class="keyword">float</span> oldVel = getCurrVelocity();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">float</span> dx = (<span class="keyword">float</span>) (mFinalX - mStartX);  </span><br><span class="line">        <span class="keyword">float</span> dy = (<span class="keyword">float</span>) (mFinalY - mStartY);  </span><br><span class="line">        <span class="keyword">float</span> hyp = FloatMath.sqrt(dx * dx + dy * dy);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">float</span> ndx = dx / hyp;  </span><br><span class="line">        <span class="keyword">float</span> ndy = dy / hyp;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">float</span> oldVelocityX = ndx * oldVel;  </span><br><span class="line">        <span class="keyword">float</span> oldVelocityY = ndy * oldVel;  </span><br><span class="line">        <span class="keyword">if</span> (Math.signum(velocityX) == Math.signum(oldVelocityX) &amp;&amp;  </span><br><span class="line">                Math.signum(velocityY) == Math.signum(oldVelocityY)) &#123;  </span><br><span class="line">            velocityX += oldVelocityX;  </span><br><span class="line">            velocityY += oldVelocityY;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    mMode = FLING_MODE;  </span><br><span class="line">    mFinished = <span class="keyword">false</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">float</span> velocity = FloatMath.sqrt(velocityX * velocityX + velocityY * velocityY);  </span><br><span class="line">   </span><br><span class="line">    mVelocity = velocity;  </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> l = Math.log(START_TENSION * velocity / ALPHA);  </span><br><span class="line">    mDuration = (<span class="keyword">int</span>) (<span class="number">1000.0</span> * Math.exp(l / (DECELERATION_RATE - <span class="number">1.0</span>)));  </span><br><span class="line">    mStartTime = AnimationUtils.currentAnimationTimeMillis();  </span><br><span class="line">    mStartX = startX;  </span><br><span class="line">    mStartY = startY;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">float</span> coeffX = velocity == <span class="number">0</span> ? <span class="number">1.0f</span> : velocityX / velocity;  </span><br><span class="line">    <span class="keyword">float</span> coeffY = velocity == <span class="number">0</span> ? <span class="number">1.0f</span> : velocityY / velocity;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> totalDistance =  </span><br><span class="line">            (<span class="keyword">int</span>) (ALPHA * Math.exp(DECELERATION_RATE / (DECELERATION_RATE - <span class="number">1.0</span>) * l));  </span><br><span class="line">      </span><br><span class="line">    mMinX = minX;  </span><br><span class="line">    mMaxX = maxX;  </span><br><span class="line">    mMinY = minY;  </span><br><span class="line">    mMaxY = maxY;  </span><br><span class="line">  </span><br><span class="line">    mFinalX = startX + Math.round(totalDistance * coeffX);  </span><br><span class="line">    <span class="comment">// Pin to mMinX &lt;= mFinalX &lt;= mMaxX  </span></span><br><span class="line">    mFinalX = Math.min(mFinalX, mMaxX);  </span><br><span class="line">    mFinalX = Math.max(mFinalX, mMinX);  </span><br><span class="line">      </span><br><span class="line">    mFinalY = startY + Math.round(totalDistance * coeffY);  </span><br><span class="line">    <span class="comment">// Pin to mMinY &lt;= mFinalY &lt;= mMaxY  </span></span><br><span class="line">    mFinalY = Math.min(mFinalY, mMaxY);  </span><br><span class="line">    mFinalY = Math.max(mFinalY, mMinY);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>滑动，这个滑动就跟GestureDetector.OnGestureListener这个接口中的onFling事件一样，根据滑动速率来判断一些事件。主要处理一些一些惯性坐标变化（惯性行为）。</p>
<ul>
<li>abortAnimation（）方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abortAnimation</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    mCurrX = mFinalX;  </span><br><span class="line">    mCurrY = mFinalY;  </span><br><span class="line">    mFinished = <span class="keyword">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>停止动画（就是设置一个标记而已，不再计算坐标的变化值）.<br>代码实现的效果图如下：<br><img src="http://1.infotravel.sinaapp.com/pic/24.gif" alt="效果如下"><br>可以看到上下左右都有弹性回弹的效果：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.chenfuduo.userinputdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.view.GestureDetector;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.Scroller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BouncyLinearLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BouncyLinearLayout"</span>;</span><br><span class="line">    <span class="keyword">private</span> Scroller mScroller;</span><br><span class="line">    <span class="keyword">private</span> GestureDetector mGestureDetector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BouncyLinearLayout</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BouncyLinearLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        setClickable(<span class="keyword">true</span>);</span><br><span class="line">        setLongClickable(<span class="keyword">true</span>);</span><br><span class="line">        mScroller = <span class="keyword">new</span> Scroller(context);</span><br><span class="line">        mGestureDetector = <span class="keyword">new</span> GestureDetector(context, <span class="keyword">new</span> BouncyGestureListener());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="javadoc">/**</span><br><span class="line">     * 滚动到目标位置</span><br><span class="line">     *<span class="javadoctag"> @param</span> fx</span><br><span class="line">     *<span class="javadoctag"> @param</span> fy</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">smoothScrollTo</span><span class="params">(<span class="keyword">int</span> fx, <span class="keyword">int</span> fy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dx = fx - mScroller.getFinalX();</span><br><span class="line">        <span class="keyword">int</span> dy = fy - mScroller.getFinalY();</span><br><span class="line">        smoothScrollBy(dx, dy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="javadoc">/**</span><br><span class="line">     * 设置滚动的相对偏移</span><br><span class="line">     *<span class="javadoctag"> @param</span> dx</span><br><span class="line">     *<span class="javadoctag"> @param</span> dy</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">smoothScrollBy</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置mScroller的滚动偏移量</span></span><br><span class="line">        mScroller.startScroll(mScroller.getFinalX(), mScroller.getFinalY(), dx, dy);</span><br><span class="line">        invalidate();<span class="comment">//这里必须调用invalidate()才能保证computeScroll()会被调用，否则不一定会刷新界面，看不到滚动效果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断mScroller滚动是否完成</span></span><br><span class="line">        <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">            <span class="comment">//这里调用View的scrollTo()完成实际的滚动</span></span><br><span class="line">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">            <span class="comment">//必须调用该方法，否则不一定能看到滚动效果</span></span><br><span class="line">            postInvalidate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.computeScroll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP :</span><br><span class="line">                smoothScrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> mGestureDetector.onTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">BouncyGestureListener</span> <span class="keyword">implements</span> <span class="title">GestureDetector</span>.<span class="title">OnGestureListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDown</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShowPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSingleTapUp</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2,</span><br><span class="line">                                <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> disX = (<span class="keyword">int</span>)((distanceX-<span class="number">0.5</span>)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> disY = (<span class="keyword">int</span>)((distanceY-<span class="number">0.5</span>)/<span class="number">2</span>);</span><br><span class="line">            smoothScrollBy(disX, disY);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLongPress</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onFling</span><span class="params">(MotionEvent e1, MotionEvent e2, <span class="keyword">float</span> velocityX,</span><br><span class="line">                               <span class="keyword">float</span> velocityY)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="处理多触摸手势">处理多触摸手势</h2><p>多点触控手势是指在同一时间有多点（手指）触碰屏幕。本部分讲述，如何检测涉及多点的触摸手势。</p>
<h3 id="追踪多点">追踪多点</h3><p>当多个手指同时触摸屏幕时，系统会产生如下的触摸事件：</p>
<blockquote>
<ul>
<li><code>ACTION_DOWN</code> - 针对触摸屏幕的第一个点。此事件是手势的开端。第一触摸点的数据在<code>MotionEvent</code>中的索引总是0。</li>
<li><code>ACTION_POINTER_DOWN</code> - 针对第一点后，出现在屏幕上额外的点。<strong>这个点的数据在MotionEvent中的索引，可以通过getActionIndex()获得。</strong></li>
<li>ACTION_MOVE - 在按下手势期间发生变化。</li>
<li>ACTION_POINTER_UP - <strong>当非主要点（non-primary pointer）离开屏幕时，发送此事件。</strong></li>
<li>ACTION_UP - 当最后一点离开屏幕时发送此事件。</li>
</ul>
</blockquote>
<p><strong>可以通过各个点的索引以及id，单独地追踪MotionEvent中的每个点。</strong></p>
<blockquote>
<ul>
<li>Index：MotionEvent把各个点的信息都存储在一个数组中。点的索引值就是它在数组中的位置。大多数用来与点交互的MotionEvent函数都是以索引值而不是点的ID作为参数的。</li>
<li>ID：每个点也都有一个ID映射，该ID映射在整个手势期间一直存在，以便我们单独地追踪每个点。</li>
</ul>
</blockquote>
<p><strong>每个独立的点在移动事件中出现的次序是不固定的。</strong>因此，从一个事件到另一个事件，点的索引值是可以改变的，但<strong>点的ID在它的生命周期内是保证不会改变的。</strong>使用<code>getPointerId()</code>可以获得一个点的ID，在手势随后的移动事件中，<code>就可以用该ID来追踪这个点</code>。对于随后一系列的事件，可以使用<strong>findPointerIndex()函数，来获得对应给定ID的点在移动事件中的索引值</strong>。如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mActivePointerId;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// Get the pointer ID</span></span><br><span class="line">    mActivePointerId = event.getPointerId(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... Many touch events later...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the pointer ID to find the index of the active pointer</span></span><br><span class="line">    <span class="comment">// and fetch its position</span></span><br><span class="line">    <span class="keyword">int</span> pointerIndex = event.findPointerIndex(mActivePointerId);</span><br><span class="line">    <span class="comment">// Get the pointer's current position</span></span><br><span class="line">    <span class="keyword">float</span> x = event.getX(pointerIndex);</span><br><span class="line">    <span class="keyword">float</span> y = event.getY(pointerIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="获取MotionEvent的动作">获取MotionEvent的动作</h3><p><strong>应该总是使用getActionMasked()函数（或者用MotionEventCompat.getActionMasked()这个兼容版本更好）来获取MotionEvent的动作(action)。</strong>与旧的getAction()函数不同的是，getActionMasked()是设计用来处理多点触摸的。它会返回执行过的动作的掩码值，不包括点的索引位。然后，我们可以使用getActionIndex()来获得与该动作关联的点的索引值。这在接下来的代码段中可以看到。</p>
<blockquote>
<p>Note: 这个样例使用的是MotionEventCompat类。该类在Support Library中。我们应该使用MotionEventCompat类，来提供对更多平台的支持。需要注意的一点是，MotionEventCompat并不是MotionEvent类的替代品。准确来说，它提供了一些静态工具类函数，我们可以把MotionEvent对象作为参数传递给这些函数，来得到与事件相关的动作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> action = MotionEventCompat.getActionMasked(event);</span><br><span class="line"><span class="comment">// Get the index of the pointer associated with the action.</span></span><br><span class="line"><span class="keyword">int</span> index = MotionEventCompat.getActionIndex(event);</span><br><span class="line"><span class="keyword">int</span> xPos = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> yPos = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Log.d(DEBUG_TAG,<span class="string">"The action is "</span> + actionToString(action));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (event.getPointerCount() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    Log.d(DEBUG_TAG,<span class="string">"Multitouch event"</span>);</span><br><span class="line">    <span class="comment">// The coordinates of the current screen contact, relative to</span></span><br><span class="line">    <span class="comment">// the responding View or Activity.</span></span><br><span class="line">    xPos = (<span class="keyword">int</span>)MotionEventCompat.getX(event, index);</span><br><span class="line">    yPos = (<span class="keyword">int</span>)MotionEventCompat.getY(event, index);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Single touch event</span></span><br><span class="line">    Log.d(DEBUG_TAG,<span class="string">"Single touch event"</span>);</span><br><span class="line">    xPos = (<span class="keyword">int</span>)MotionEventCompat.getX(event, index);</span><br><span class="line">    yPos = (<span class="keyword">int</span>)MotionEventCompat.getY(event, index);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Given an action int, returns a string description</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">actionToString</span><span class="params">(<span class="keyword">int</span> action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN: <span class="keyword">return</span> <span class="string">"Down"</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE: <span class="keyword">return</span> <span class="string">"Move"</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_POINTER_DOWN: <span class="keyword">return</span> <span class="string">"Pointer Down"</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP: <span class="keyword">return</span> <span class="string">"Up"</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_POINTER_UP: <span class="keyword">return</span> <span class="string">"Pointer Up"</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_OUTSIDE: <span class="keyword">return</span> <span class="string">"Outside"</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: <span class="keyword">return</span> <span class="string">"Cancel"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="拖拽与缩放">拖拽与缩放</h2><p>本部分讲述，使用<code>onTouchEvent()</code>截获触摸事件后，如何使用触摸手势拖拽、缩放屏幕上的对象。</p>
<h3 id="拖拽一个对象">拖拽一个对象</h3><blockquote>
<p>如果我们的目标版本为3.0或以上，我们可以使用<code>View.OnDragListener</code>监听内置的拖放（drag-and-drop）事件，拖拽与释放中有更多相关描述。</p>
</blockquote>
<p>对于触摸手势来说，一个很常见的操作是在屏幕上拖拽一个对象。接下来的代码段让用户可以拖拽屏幕上的图片。需要注意以下几点：</p>
<blockquote>
<ul>
<li>拖拽操作时，即使有额外的手指放置到屏幕上了，app也必须保持对最初的点（手指）的追踪。比如，想象在拖拽图片时，用户放置了第二根手指在屏幕上，并且抬起了第一根手指。如果我们的app只是单独地追踪每个点，它会把第二个点当做默认的点，并且把图片移到该点的位置。</li>
<li>为了防止这种情况发生，我们的app需要区分初始点以及随后任意的触摸点。要做到这一点，它需要追踪处理多触摸手势章节中提到过的 <code>ACTION_POINTER_DOWN</code> 和 <code>ACTION_POINTER_UP</code> 事件。每当第二根手指按下或拿起时，<code>ACTION_POINTER_DOWN</code>和 <code>ACTION_POINTER_UP</code> 事件就会传递给<code>onTouchEvent()</code>回调函数。</li>
<li>当<code>ACTION_POINTER_UP</code>事件发生时，示例程序会移除对该点的索引值的引用，确保操作中的点的ID(the active pointer ID)不会引用已经不在触摸屏上的触摸点。这种情况下，app会选择另一个触摸点来作为操作中(active)的点，并保存它当前的x、y值。由于在ACTION_MOVE事件时，这个保存的位置会被用来计算屏幕上的对象将要移动的距离，所以app会始终根据正确的触摸点来计算移动的距离。</li>
</ul>
</blockquote>
<p>下面的代码段允许用户拖拽屏幕上的对象。它会记录操作中的点（active pointer）的初始位置，计算触摸点移动过的距离，再把对象移动到新的位置。如上所述，它也正确地处理了额外触摸点的可能。</p>
<p>需要注意的是，代码段中使用了getActionMasked()函数。我们应该始终使用这个函数（或者最好用MotionEventCompat.getActionMasked()这个兼容版本）来获得MotionEvent对应的动作(action)。不像旧的getAction()函数，getActionMasked()就是设计用来处理多点触摸的。它会返回执行过的动作的掩码值，不包括该点的索引位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The ‘active pointer’ is the one currently moving our object.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mActivePointerId = INVALID_POINTER_ID;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Let the ScaleGestureDetector inspect all events.</span></span><br><span class="line">    mScaleDetector.onTouchEvent(ev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pointerIndex = MotionEventCompat.getActionIndex(ev);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, pointerIndex);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, pointerIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remember where we started (for dragging)</span></span><br><span class="line">        mLastTouchX = x;</span><br><span class="line">        mLastTouchY = y;</span><br><span class="line">        <span class="comment">// Save the ID of this pointer (for dragging)</span></span><br><span class="line">        mActivePointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">        <span class="comment">// Find the index of the active pointer and fetch its position</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pointerIndex =</span><br><span class="line">                MotionEventCompat.findPointerIndex(ev, mActivePointerId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> x = MotionEventCompat.getX(ev, pointerIndex);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> y = MotionEventCompat.getY(ev, pointerIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Calculate the distance moved</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> dx = x - mLastTouchX;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">float</span> dy = y - mLastTouchY;</span><br><span class="line"></span><br><span class="line">        mPosX += dx;</span><br><span class="line">        mPosY += dy;</span><br><span class="line"></span><br><span class="line">        invalidate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remember this touch position for the next move event</span></span><br><span class="line">        mLastTouchX = x;</span><br><span class="line">        mLastTouchY = y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">        mActivePointerId = INVALID_POINTER_ID;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">        mActivePointerId = INVALID_POINTER_ID;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_POINTER_UP: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pointerIndex = MotionEventCompat.getActionIndex(ev);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pointerId == mActivePointerId) &#123;</span><br><span class="line">            <span class="comment">// This was our active pointer going up. Choose a new</span></span><br><span class="line">            <span class="comment">// active pointer and adjust accordingly.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> newPointerIndex = pointerIndex == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            mLastTouchX = MotionEventCompat.getX(ev, newPointerIndex);</span><br><span class="line">            mLastTouchY = MotionEventCompat.getY(ev, newPointerIndex);</span><br><span class="line">            mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="通过拖拽平移">通过拖拽平移</h3><p>前一节展示了一个，在屏幕上拖拽对象的例子。另一个常见的场景是平移（panning），平移是指用户通过拖拽移动引起x、y轴方向发生滚动(scrolling)。上面的代码段直接截获了MotionEvent动作来实现拖拽。这一部分的代码段，利用了平台对常用手势的内置支持。它重写了<code>GestureDetector.SimpleOnGestureListener</code>的<code>onScroll()</code>函数。</p>
<p>更详细地说，当用户拖拽手指来平移内容时，onScroll()函数就会被调用。onScroll()函数只会在手指按下的情况下被调用，一旦手指离开屏幕了，要么手势终止，要么快速滑动(fling)手势开始<br>这里是onScroll()的相关代码段：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The current viewport. This rectangle represents the currently visible</span></span><br><span class="line"><span class="comment">// chart domain and range.</span></span><br><span class="line"><span class="keyword">private</span> RectF mCurrentViewport =</span><br><span class="line">        <span class="keyword">new</span> RectF(AXIS_X_MIN, AXIS_Y_MIN, AXIS_X_MAX, AXIS_Y_MAX);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The current destination rectangle (in pixel coordinates) into which the</span></span><br><span class="line"><span class="comment">// chart data should be drawn.</span></span><br><span class="line"><span class="keyword">private</span> Rect mContentRect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> GestureDetector.SimpleOnGestureListener mGestureListener</span><br><span class="line">            = <span class="keyword">new</span> GestureDetector.SimpleOnGestureListener() &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScroll</span><span class="params">(MotionEvent e1, MotionEvent e2,</span><br><span class="line">            <span class="keyword">float</span> distanceX, <span class="keyword">float</span> distanceY)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Scrolling uses math based on the viewport (as opposed to math using pixels).</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pixel offset is the offset in screen pixels, while viewport offset is the</span></span><br><span class="line">    <span class="comment">// offset within the current viewport.</span></span><br><span class="line">    <span class="keyword">float</span> viewportOffsetX = distanceX * mCurrentViewport.width()</span><br><span class="line">            / mContentRect.width();</span><br><span class="line">    <span class="keyword">float</span> viewportOffsetY = -distanceY * mCurrentViewport.height()</span><br><span class="line">            / mContentRect.height();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Updates the viewport, refreshes the display.</span></span><br><span class="line">    setViewportBottomLeft(</span><br><span class="line">            mCurrentViewport.left + viewportOffsetX,</span><br><span class="line">            mCurrentViewport.bottom + viewportOffsetY);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>onScroll()函数中滑动视窗(viewport)来响应触摸手势的实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Sets the current viewport (defined by mCurrentViewport) to the given</span><br><span class="line"> * X and Y positions. Note that the Y value represents the topmost pixel position,</span><br><span class="line"> * and thus the bottom of the mCurrentViewport rectangle.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setViewportBottomLeft</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Constrains within the scroll range. The scroll range is simply the viewport</span><br><span class="line">     * extremes (AXIS_X_MAX, etc.) minus the viewport size. For example, if the</span><br><span class="line">     * extremes were 0 and 10, and the viewport size was 2, the scroll range would</span><br><span class="line">     * be 0 to 8.</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> curWidth = mCurrentViewport.width();</span><br><span class="line">    <span class="keyword">float</span> curHeight = mCurrentViewport.height();</span><br><span class="line">    x = Math.max(AXIS_X_MIN, Math.min(x, AXIS_X_MAX - curWidth));</span><br><span class="line">    y = Math.max(AXIS_Y_MIN + curHeight, Math.min(y, AXIS_Y_MAX));</span><br><span class="line"></span><br><span class="line">    mCurrentViewport.set(x, y - curHeight, x + curWidth, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invalidates the View to update the display.</span></span><br><span class="line">    ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用触摸手势进行缩放">使用触摸手势进行缩放</h3><p>GestureDetector可以帮助我们检测Android中的常见手势，例如滚动，快速滚动以及长按。对于缩放，Android也提供了<code>ScaleGestureDetector</code>类。当我们想让view能识别额外的手势时，我们可以同时使用GestureDetector和ScaleGestureDetector类。</p>
<p>为了报告检测到的手势事件，手势检测需要一个作为构造函数参数的listener对象。<code>ScaleGestureDetector</code>使用<code>ScaleGestureDetector.OnScaleGestureListener</code>。Android提供了<code>ScaleGestureDetector.SimpleOnScaleGestureListener</code>类作为帮助类，如果我们不是关注所有的手势事件，我们可以继承(extend)它。</p>
<h3 id="基本的缩放示例">基本的缩放示例</h3><p>下面的代码段展示了缩放功能中的基本部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ScaleGestureDetector mScaleDetector;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> mScaleFactor = <span class="number">1.f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyCustomView</span><span class="params">(Context mContext)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// View code goes here</span></span><br><span class="line">    ...</span><br><span class="line">    mScaleDetector = <span class="keyword">new</span> ScaleGestureDetector(context, <span class="keyword">new</span> ScaleListener());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Let the ScaleGestureDetector inspect all events.</span></span><br><span class="line">    mScaleDetector.onTouchEvent(ev);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    canvas.save();</span><br><span class="line">    canvas.scale(mScaleFactor, mScaleFactor);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// onDraw() code goes here</span></span><br><span class="line">    ...</span><br><span class="line">    canvas.restore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScaleListener</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title">ScaleGestureDetector</span>.<span class="title">SimpleOnScaleGestureListener</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScale</span><span class="params">(ScaleGestureDetector detector)</span> </span>&#123;</span><br><span class="line">        mScaleFactor *= detector.getScaleFactor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't let the object get too small or too large.</span></span><br><span class="line">        mScaleFactor = Math.max(<span class="number">0.1f</span>, Math.min(mScaleFactor, <span class="number">5.0f</span>));</span><br><span class="line"></span><br><span class="line">        invalidate();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更加复杂的缩放示例">更加复杂的缩放示例</h3><p>这是本章节提供的InteractiveChart示例中一个更复杂的示范。通过使用ScaleGestureDetector中的”span”(getCurrentSpanX/Y)和”focus”(getFocusX/Y)功能，InteractiveChart示例同时支持滚动（平移）以及多指缩放。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">private</span> RectF mCurrentViewport =</span><br><span class="line">        <span class="keyword">new</span> RectF(AXIS_X_MIN, AXIS_Y_MIN, AXIS_X_MAX, AXIS_Y_MAX);</span><br><span class="line"><span class="keyword">private</span> Rect mContentRect;</span><br><span class="line"><span class="keyword">private</span> ScaleGestureDetector mScaleGestureDetector;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> retVal = mScaleGestureDetector.onTouchEvent(event);</span><br><span class="line">    retVal = mGestureDetector.onTouchEvent(event) || retVal;</span><br><span class="line">    <span class="keyword">return</span> retVal || <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javadoc">/**</span><br><span class="line"> * The scale listener, used for handling multi-finger scale gestures.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ScaleGestureDetector.OnScaleGestureListener mScaleGestureListener</span><br><span class="line">        = <span class="keyword">new</span> ScaleGestureDetector.SimpleOnScaleGestureListener() &#123;</span><br><span class="line">    <span class="javadoc">/**</span><br><span class="line">     * This is the active focal point in terms of the viewport. Could be a local</span><br><span class="line">     * variable but kept here to minimize per-frame allocations.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> PointF viewportFocus = <span class="keyword">new</span> PointF();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lastSpanX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lastSpanY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detects that new pointers are going down.</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScaleBegin</span><span class="params">(ScaleGestureDetector scaleGestureDetector)</span> </span>&#123;</span><br><span class="line">        lastSpanX = ScaleGestureDetectorCompat.</span><br><span class="line">                getCurrentSpanX(scaleGestureDetector);</span><br><span class="line">        lastSpanY = ScaleGestureDetectorCompat.</span><br><span class="line">                getCurrentSpanY(scaleGestureDetector);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onScale</span><span class="params">(ScaleGestureDetector scaleGestureDetector)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> spanX = ScaleGestureDetectorCompat.</span><br><span class="line">                getCurrentSpanX(scaleGestureDetector);</span><br><span class="line">        <span class="keyword">float</span> spanY = ScaleGestureDetectorCompat.</span><br><span class="line">                getCurrentSpanY(scaleGestureDetector);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> newWidth = lastSpanX / spanX * mCurrentViewport.width();</span><br><span class="line">        <span class="keyword">float</span> newHeight = lastSpanY / spanY * mCurrentViewport.height();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> focusX = scaleGestureDetector.getFocusX();</span><br><span class="line">        <span class="keyword">float</span> focusY = scaleGestureDetector.getFocusY();</span><br><span class="line">        <span class="comment">// Makes sure that the chart point is within the chart region.</span></span><br><span class="line">        <span class="comment">// See the sample for the implementation of hitTest().</span></span><br><span class="line">        hitTest(scaleGestureDetector.getFocusX(),</span><br><span class="line">                scaleGestureDetector.getFocusY(),</span><br><span class="line">                viewportFocus);</span><br><span class="line"></span><br><span class="line">        mCurrentViewport.set(</span><br><span class="line">                viewportFocus.x</span><br><span class="line">                        - newWidth * (focusX - mContentRect.left)</span><br><span class="line">                        / mContentRect.width(),</span><br><span class="line">                viewportFocus.y</span><br><span class="line">                        - newHeight * (mContentRect.bottom - focusY)</span><br><span class="line">                        / mContentRect.height(),</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>);</span><br><span class="line">        mCurrentViewport.right = mCurrentViewport.left + newWidth;</span><br><span class="line">        mCurrentViewport.bottom = mCurrentViewport.top + newHeight;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Invalidates the View to update the display.</span></span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(InteractiveLineGraphView.<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        lastSpanX = spanX;</span><br><span class="line">        lastSpanY = spanY;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="管理ViewGroup中的触摸事件">管理ViewGroup中的触摸事件</h2><p>因为很多时候是用ViewGroup的子类来做不同触摸事件的目标，而不是ViewGroup本身，所以处理ViewGroup中的触摸事件需要特别注意。 为了确保每个view能正确地接收到它们想要的触摸事件，可以重写<code>onInterceptTouchEvent()</code>函数。</p>
<h3 id="在ViewGroup中截获触摸事件">在ViewGroup中截获触摸事件</h3><p><strong>每当在ViewGroup（包括它的子View）的表面上检测到一个触摸事件，onInterceptTouchEvent()都会被调用。如果onInterceptTouchEvent()返回true，MotionEvent就被截获了，这表示它不会被传递给其子View，而是传递给该父view自身的onTouchEvent()方法。</strong></p>
<p><code>onInterceptTouchEvent()</code>方法让父view能够在它的子view之前处理触摸事件。如果我们让onInterceptTouchEvent()返回true，则之前处理触摸事件的子view会收到ACTION_CANCEL事件，并且该点之后的事件会被发送给该父view自身的onTouchEvent()函数，进行常规处理。onInterceptTouchEvent()也可以返回false，这样事件沿view层级分发到目标前，父view可以简单地观察该事件。这里的目标是指，通过onTouchEvent()处理消息事件的view。</p>
<p>接下来的代码段中，MyViewGroup继承自ViewGroup。MyViewGroup有多个子view。如果我们在某个子View上水平地拖动手指，该子view不会接收到触摸事件，而是应该由MyViewGroup处理这些触摸事件来滚动它的内容。然而，如果我们点击子view中的button，或垂直地滚动子view，则父view不会截获这些触摸事件，因为子view本身就是预定目标。在这些情况下，onInterceptTouchEvent()应该返回false，MyViewGroup的onTouchEvent()也不会被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewGroup</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mTouchSlop;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ViewConfiguration vc = ViewConfiguration.get(view.getContext());</span><br><span class="line">    mTouchSlop = vc.getScaledTouchSlop();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * This method JUST determines whether we want to intercept the motion.</span><br><span class="line">         * If we return true, onTouchEvent will be called and we do the actual</span><br><span class="line">         * scrolling there.</span><br><span class="line">         */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Always handle the case of the touch gesture being complete.</span></span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) &#123;</span><br><span class="line">            <span class="comment">// Release the scroll.</span></span><br><span class="line">            mIsScrolling = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// Do not intercept touch event, let the child handle it</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsScrolling) &#123;</span><br><span class="line">                    <span class="comment">// We're currently scrolling, so yes, intercept the</span></span><br><span class="line">                    <span class="comment">// touch event!</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If the user has dragged her finger horizontally more than</span></span><br><span class="line">                <span class="comment">// the touch slop, start the scroll</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// left as an exercise for the reader</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> xDiff = calculateDistanceX(ev);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Touch slop should be calculated using ViewConfiguration</span></span><br><span class="line">                <span class="comment">// constants.</span></span><br><span class="line">                <span class="keyword">if</span> (xDiff &gt; mTouchSlop) &#123;</span><br><span class="line">                    <span class="comment">// Start scrolling!</span></span><br><span class="line">                    mIsScrolling = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In general, we don't want to intercept touch events. They should be</span></span><br><span class="line">        <span class="comment">// handled by the child view.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Here we actually handle the touch event (e.g. if the action is ACTION_MOVE,</span></span><br><span class="line">        <span class="comment">// scroll this container).</span></span><br><span class="line">        <span class="comment">// This method will only be called if the touch event was intercepted in</span></span><br><span class="line">        <span class="comment">// onInterceptTouchEvent</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意ViewGroup也提供了<code>requestDisallowInterceptTouchEvent()</code>方法。当子view不想该父view和祖先view通过onInterceptTouchEvent()截获它的触摸事件时，可调用ViewGroup的该方法。</p>
<hr>
<h3 id="使用ViewConfiguration的常量">使用ViewConfiguration的常量</h3><p>上面的代码段中使用了当前的ViewConfiguration来初始化mTouchSlop变量。我们可以使用<code>ViewConfiguration</code>类来获取Android系统常用的一些距离、速度、时间值。</p>
<p>“Touch slop”是指在被识别为移动的手势前，用户触摸可移动的那一段像素距离。Touch slop通常用来预防用户在做一些其他触摸操作时，出现意外地滑动，例如触摸屏幕上的组件。</p>
<p>另外两个常用的ViewConfiguration函数是<code>getScaledMinimumFlingVelocity()</code>和<code>getScaledMaximumFlingVelocity()</code>。这两个函数会返回初始化一个快速滑动(fling)的最小、最大速度（分别地），以像素每秒为测量单位。如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ViewConfiguration vc = ViewConfiguration.get(view.getContext());</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mSlop = vc.getScaledTouchSlop();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">float</span> deltaX = motionEvent.getRawX() - mDownX;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(deltaX) &gt; mSlop) &#123;</span><br><span class="line">        <span class="comment">// A swipe occurred, do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125; <span class="keyword">if</span> (mMinFlingVelocity &lt;= velocityX &amp;&amp; velocityX &lt;= mMaxFlingVelocity</span><br><span class="line">            &amp;&amp; velocityY &lt; velocityX) &#123;</span><br><span class="line">        <span class="comment">// The criteria have been satisfied, do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="扩展子view的可触摸区域">扩展子view的可触摸区域</h3><p>Android提供了<code>TouchDelegate</code>类，让父view扩展超出子view自身边界的可触摸区域。这在当子view很小，但需要一个更大的触摸区域时非常有用。如果需要，我们也可以使用这种方式来实现对子view的触摸区域的收缩。</p>
<p>在下面的例子中，ImageButton对象是所谓的”delegate view”（是指触摸区域将被父view扩展的那个子view）。这是布局文件：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">     <span class="attribute">android:id</span>=<span class="value">"@+id/parent_layout"</span></span><br><span class="line">     <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">     <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">     <span class="attribute">tools:context</span>=<span class="value">".MainActivity"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="title">ImageButton</span> <span class="attribute">android:id</span>=<span class="value">"@+id/button"</span></span><br><span class="line">          <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">          <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">          <span class="attribute">android:background</span>=<span class="value">"@null"</span></span><br><span class="line">          <span class="attribute">android:src</span>=<span class="value">"@drawable/icon"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>下面的代码段做了这样几件事：</p>
<blockquote>
<ul>
<li>获得父view对象并发送一个Runnable到UI线程。这会确保父view在调用getHitRect()函数前会布局它的子view。getHitRect()函数会获得子view在父view坐标系中的点击矩形（触摸区域）。</li>
<li>找到ImageButton子view，然后调用getHitRect()来获得它的触摸区域的边界。</li>
<li>扩展ImageButton的点击矩形的边界。</li>
<li>实例化一个TouchDelegate对象，并把扩展过的点击矩形和ImageButton子view作为参数传递给它。</li>
<li>设置父view的TouchDelegate，这样在touch delegate边界内的点击就会传递到该子view上。</li>
</ul>
</blockquote>
<p>在ImageButton子view的touch delegate范围内，父view会接收到所有的触摸事件。如果触摸事件发生在子view自身的点击矩形中，父view会把触摸事件交给子view处理。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">// Get the parent view</span></span><br><span class="line">        View parentView = findViewById(R.id.parent_layout);</span><br><span class="line"></span><br><span class="line">        parentView.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="comment">// Post in the parent's message queue to make sure the parent</span></span><br><span class="line">            <span class="comment">// lays out its children before you call getHitRect()</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// The bounds for the delegate view (an ImageButton</span></span><br><span class="line">                <span class="comment">// in this example)</span></span><br><span class="line">                Rect delegateArea = <span class="keyword">new</span> Rect();</span><br><span class="line">                ImageButton myButton = (ImageButton) findViewById(R.id.button);</span><br><span class="line">                myButton.setEnabled(<span class="keyword">true</span>);</span><br><span class="line">                myButton.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                        Toast.makeText(MainActivity.<span class="keyword">this</span>,</span><br><span class="line">                                <span class="string">"Touch occurred within ImageButton touch region."</span>,</span><br><span class="line">                                Toast.LENGTH_SHORT).show();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// The hit rectangle for the ImageButton</span></span><br><span class="line">                myButton.getHitRect(delegateArea);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Extend the touch area of the ImageButton beyond its bounds</span></span><br><span class="line">                <span class="comment">// on the right and bottom.</span></span><br><span class="line">                delegateArea.right += <span class="number">100</span>;</span><br><span class="line">                delegateArea.bottom += <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Instantiate a TouchDelegate.</span></span><br><span class="line">                <span class="comment">// "delegateArea" is the bounds in local coordinates of</span></span><br><span class="line">                <span class="comment">// the containing view to be mapped to the delegate view.</span></span><br><span class="line">                <span class="comment">// "myButton" is the child view that should receive motion</span></span><br><span class="line">                <span class="comment">// events.</span></span><br><span class="line">                TouchDelegate touchDelegate = <span class="keyword">new</span> TouchDelegate(delegateArea,</span><br><span class="line">                        myButton);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Sets the TouchDelegate on the parent view, such that touches</span></span><br><span class="line">                <span class="comment">// within the touch delegate bounds are routed to the child.</span></span><br><span class="line">                <span class="keyword">if</span> (View.class.isInstance(myButton.getParent())) &#123;</span><br><span class="line">                    ((View) myButton.getParent()).setTouchDelegate(touchDelegate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="处理键盘输入">处理键盘输入</h1><p>当当前焦点在 UI 的文本框上时，Android 系统会在屏幕上显示一个键盘 － 被称为软输入法。为了提供最好的用户体验，我们可以指定我们期望的输入类型的特征（例如，是否是电话号码或Email地址）和输入法的表现形式（例如，是否需要自动纠正拼写错误）。<br>下面的部分就讨论这些内容。</p>
<h2 id="指定输入法类型">指定输入法类型</h2><p>每个文本框都对应特定类型的文本输入，如Email地址，电话号码，或者纯文本。为应用中的每一个文本框指定输入类型是很重要的，这样做可以让系统展示更为合适的软输入法（比如虚拟键盘）。</p>
<p>除了输入法可用的按钮类型之外，我们还应该指定一些行为，例如，输入法是否提供拼写建议，新的句子首字母大写，和将回车按钮替换成动作按钮（如 Done 或者 Next）。本部分介绍如何添加这些属性。</p>
<h3 id="指定键盘类型">指定键盘类型</h3><p>通过将 <code>android:inputType</code> 属性添加到 <code>&lt;EditText&gt;</code> 节点中，我们可以为文本框声明输入法。</p>
<p>举例来说，如果我们想要一个用于输入电话号码的输入法，那么使用 <code>&quot;phone&quot;</code> 值：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">EditText</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/phone"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:hint</span>=<span class="value">"@string/phone_hint"</span></span><br><span class="line">    <span class="attribute">android:inputType</span>=<span class="value">"phone"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>或者如果文本框用于输入密码，那么使用 <code>&quot;textPassword&quot;</code> 值来隐藏用户的输入：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">EditText</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/password"</span></span><br><span class="line">    <span class="attribute">android:hint</span>=<span class="value">"@string/password_hint"</span></span><br><span class="line">    <span class="attribute">android:inputType</span>=<span class="value">"textPassword"</span></span><br><span class="line">    <span class="attribute">...</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>有几种可供选择的值在 <code>android:inputType</code> 记录在属性中，一些值可以组合起来实现特定的输入法外观和附加的行为。</p>
<h3 id="开启拼写建议和其它行为">开启拼写建议和其它行为</h3><p><code>android:inputType</code> 属性允许我们为输入法指定不同的行为。最为重要的是，如果文本框用于基本的文本输入（如短信息），那么我们应该使用 <code>&quot;textAutoCorrect&quot;</code> 值来开启自动拼写修正。</p>
<p>我们可以将不同的行为和输入法形式组合到 <code>android:inputType</code> 这个属性。如：如何创建一个文本框，<strong>里面的句子首字母大写并开启拼写修正</strong>：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">EditText</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/message"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:inputType</span>=</span><br><span class="line">        "<span class="attribute">textCapSentences</span>|<span class="attribute">textAutoCorrect</span>"</span><br><span class="line">    <span class="attribute">...</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="指定输入法的行为">指定输入法的行为</h3><p>多数的软键盘会在底部角落里为用户提供一个合适的动作按钮来触发当前文本框的操作。默认情况下，系统使用<strong> Next 或者 Done</strong>，除非我们的文本框允许多行文本（如android:inputType=”textMultiLine”），这种情况下，动作按钮就是回车换行。然而，我们可以指定一些更适合我们文本框的额外动作，比如 <code>Send 和 Go</code>。<br>使用<code>android:imeOptions</code>属性，并设置一个动作值（如 “actionSend” 或 “actionSearch”），来指定键盘的动作按钮。如：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">EditText</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/search"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"fill_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:hint</span>=<span class="value">"@string/search_hint"</span></span><br><span class="line">    <span class="attribute">android:inputType</span>=<span class="value">"text"</span></span><br><span class="line">    <span class="attribute">android:imeOptions</span>=<span class="value">"actionSend"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后，我们可以通过为 EditText 节点定义 <code>TextView.OnEditorActionListener</code>来监听动作按钮的按压。在监听器中，响应 <code>EditorInfo</code> 类中定义的适合的 <code>IME action ID</code>，如 <code>IME_ACTION_SEND</code> 。例如:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EditText editText = (EditText) findViewById(R.id.search);</span><br><span class="line">editText.setOnEditorActionListener(<span class="keyword">new</span> OnEditorActionListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onEditorAction</span><span class="params">(TextView v, <span class="keyword">int</span> actionId, KeyEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (actionId == EditorInfo.IME_ACTION_SEND) &#123;</span><br><span class="line">            sendMessage();</span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="处理输入法的显示">处理输入法的显示</h2><p>当输入焦点移入或移出可编辑的文本框时，Android会相应的显示或隐藏输入法（如虚拟键盘）。系统也会决定输入法上方的 UI 和文本框的显示方式。举例来说，当屏幕上垂直空间被压缩时，文本框可能填充输入法上方所有的空间。对于多数的应用来说，这些默认的行为基本就足够了。</p>
<p>然而，在一些事例中，我们可能会想要更加直接地控制输入法的显示，指定在输入法显示的时候，如何显示我们的布局。本部分会解释如何控制和响应输入法的可见性。</p>
<h3 id="在Activity启动时显示输入法">在Activity启动时显示输入法</h3><p>尽管Android会在Activity启动时将焦点放在布局中的第一个文本框，但是并不会显示输入法。因为输入文本可能并不是activity中 的首要任务，所以不显示输入法是很合理的。可是，如果输入文本确实是首要的任务（如在登录界面中），那么可能需要默认显示输入法。</p>
<p>为了在activity启动时显示输入法，添加 <code>android:windowSoftInputMode</code> 属性到 <code>&lt;activity&gt;</code> 节点中，并将该属性的值设为 <code>&quot;stateVisible&quot;</code>。如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">application</span> <span class="attribute">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">        <span class="attribute">android:windowSoftInputMode</span>=<span class="value">"stateVisible"</span> <span class="attribute">...</span> &gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Note: 如果用户的设备有一个实体键盘，那么不会显示软输入法。</p>
</blockquote>
<h3 id="根据需要显示输入法">根据需要显示输入法</h3><p>如果我们想要确保输入法在activity生命周期的某个方法中是可见的，那么可以使用 <code>InputMethodManager</code> 来实现。</p>
<p>举例来说，下面的方法调用了一个需要用户填写文本的View，调用了 <code>requestFocus()</code> 来获取焦点，然后调用 <code>showSoftInput()</code> 来打开输入法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showSoftKeyboard</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (view.requestFocus()) &#123;</span><br><span class="line">        InputMethodManager imm = (InputMethodManager)</span><br><span class="line">                getSystemService(Context.INPUT_METHOD_SERVICE);</span><br><span class="line">        imm.showSoftInput(view, InputMethodManager.SHOW_IMPLICIT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Note: 一旦输入法可见，我们不应该以编程的方式来隐藏它。系统会在用户结束文本框的任务时隐藏输入法，或者可以使用系统控制（如返回键）来隐藏。</p>
</blockquote>
<h3 id="指定_UI_的响应方式">指定 UI 的响应方式</h3><p>当输入法显示在屏幕上时，会减少 app UI 中的可用空间。系统会决定如何调整 UI 可见的部分，但是这样做不一定正确。为了确保应用的最佳表现，我们应该在 UI 的剩余空间中展示我们想要展示的系统界面。</p>
<p>为了在activity中声明合适的处理方法，可以在 manifest 文件的 <activity> 节点中使用 <code>android:windowSoftInputMode</code> 属性，并将该属性的值设为<code>&quot;adjust&quot;</code>。</activity></p>
<p>举例来说，为了确保系统会在可用空间中重新调整布局的大小——确保所有的布局内容都可以被使用（尽管可能需要滑动）——使用 “adjustResize”:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">application</span> <span class="attribute">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">        <span class="attribute">android:windowSoftInputMode</span>=<span class="value">"adjustResize"</span> <span class="attribute">...</span> &gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以结合上述调整说明和初始化输入法可见性说明：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">activity</span></span><br><span class="line">    <span class="attribute">android:windowSoftInputMode</span>=<span class="value">"stateVisible|adjustResize"</span> <span class="attribute">...</span> &gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果 UI 中包含用户可能需要在文本输入时立即执行的事情，那么使用 “adjustResize” 是很重要的。例如，如果我们使用相对布局（relative layout）在屏幕底部放置一个按钮，用 “adjustResize” 来重新调整大小，使得按钮栏出现在输入法上方。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/移动开发/">移动开发</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/移动开发/">移动开发</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://chenfuduo.me/2015/07/02/training-for-the-thirteenth-part/" data-title="training for the thirteenth part | louis.chen" data-tsina="2338582935" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/07/10/EventBus使用案例和源码分析/" title="EventBus使用案例和源码分析">
  <strong>上一篇：</strong><br/>
  <span>
  EventBus使用案例和源码分析</span>
</a>
</div>


<div class="next">
<a href="/2015/07/01/training-for-the-twelfth-part/"  title="training for the twelfth part">
 <strong>下一篇：</strong><br/> 
 <span>training for the twelfth part
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/07/02/training-for-the-thirteenth-part/" data-title="training for the thirteenth part" data-url="http://chenfuduo.me/2015/07/02/training-for-the-thirteenth-part/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#使用触摸手势"><span class="toc-number">1.</span> <span class="toc-text">使用触摸手势</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#检测常用的手势"><span class="toc-number">1.1.</span> <span class="toc-text">检测常用的手势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Support_Library_中的类"><span class="toc-number">1.1.1.</span> <span class="toc-text">Support Library 中的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#收集数据"><span class="toc-number">1.1.2.</span> <span class="toc-text">收集数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为Activity或View捕获触摸事件"><span class="toc-number">1.1.3.</span> <span class="toc-text">为Activity或View捕获触摸事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#捕获单个view的触摸事件"><span class="toc-number">1.1.4.</span> <span class="toc-text">捕获单个view的触摸事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检测手势"><span class="toc-number">1.1.5.</span> <span class="toc-text">检测手势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检测所有支持的手势"><span class="toc-number">1.1.6.</span> <span class="toc-text">检测所有支持的手势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检测部分支持的手势"><span class="toc-number">1.1.7.</span> <span class="toc-text">检测部分支持的手势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#追踪手势移动"><span class="toc-number">1.2.</span> <span class="toc-text">追踪手势移动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#追踪速度"><span class="toc-number">1.2.1.</span> <span class="toc-text">追踪速度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scroll手势动画"><span class="toc-number">1.3.</span> <span class="toc-text">Scroll手势动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#理解滚动术语"><span class="toc-number">1.3.1.</span> <span class="toc-text">理解滚动术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现基于触摸的滚动"><span class="toc-number">1.3.2.</span> <span class="toc-text">实现基于触摸的滚动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于scroller"><span class="toc-number">1.3.3.</span> <span class="toc-text">关于scroller</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理多触摸手势"><span class="toc-number">1.4.</span> <span class="toc-text">处理多触摸手势</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#追踪多点"><span class="toc-number">1.4.1.</span> <span class="toc-text">追踪多点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取MotionEvent的动作"><span class="toc-number">1.4.2.</span> <span class="toc-text">获取MotionEvent的动作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拖拽与缩放"><span class="toc-number">1.5.</span> <span class="toc-text">拖拽与缩放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#拖拽一个对象"><span class="toc-number">1.5.1.</span> <span class="toc-text">拖拽一个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过拖拽平移"><span class="toc-number">1.5.2.</span> <span class="toc-text">通过拖拽平移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用触摸手势进行缩放"><span class="toc-number">1.5.3.</span> <span class="toc-text">使用触摸手势进行缩放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本的缩放示例"><span class="toc-number">1.5.4.</span> <span class="toc-text">基本的缩放示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更加复杂的缩放示例"><span class="toc-number">1.5.5.</span> <span class="toc-text">更加复杂的缩放示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管理ViewGroup中的触摸事件"><span class="toc-number">1.6.</span> <span class="toc-text">管理ViewGroup中的触摸事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在ViewGroup中截获触摸事件"><span class="toc-number">1.6.1.</span> <span class="toc-text">在ViewGroup中截获触摸事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用ViewConfiguration的常量"><span class="toc-number">1.6.2.</span> <span class="toc-text">使用ViewConfiguration的常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展子view的可触摸区域"><span class="toc-number">1.6.3.</span> <span class="toc-text">扩展子view的可触摸区域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#处理键盘输入"><span class="toc-number">2.</span> <span class="toc-text">处理键盘输入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#指定输入法类型"><span class="toc-number">2.1.</span> <span class="toc-text">指定输入法类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指定键盘类型"><span class="toc-number">2.1.1.</span> <span class="toc-text">指定键盘类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开启拼写建议和其它行为"><span class="toc-number">2.1.2.</span> <span class="toc-text">开启拼写建议和其它行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指定输入法的行为"><span class="toc-number">2.1.3.</span> <span class="toc-text">指定输入法的行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理输入法的显示"><span class="toc-number">2.2.</span> <span class="toc-text">处理输入法的显示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在Activity启动时显示输入法"><span class="toc-number">2.2.1.</span> <span class="toc-text">在Activity启动时显示输入法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#根据需要显示输入法"><span class="toc-number">2.2.2.</span> <span class="toc-text">根据需要显示输入法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指定_UI_的响应方式"><span class="toc-number">2.2.3.</span> <span class="toc-text">指定 UI 的响应方式</span></a></li></ol></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/收藏/" title="收藏">收藏<sup>1</sup></a></li>
		  
		
		  
		
		  
			<li><a href="/categories/移动开发/" title="移动开发">移动开发<sup>42</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/移动开发/" title="移动开发">移动开发<sup>42</sup></a></li>
			
		
			
				<li><a href="/tags/自定义View/" title="自定义View">自定义View<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/UI-UE/" title="UI/UE">UI/UE<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/自定义控件/" title="自定义控件">自定义控件<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/ViewDragHelper/" title="ViewDragHelper">ViewDragHelper<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Design-Support-Library/" title="Design Support Library">Design Support Library<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/收藏/" title="收藏">收藏<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/EventBus/" title="EventBus">EventBus<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Bundle/" title="Bundle">Bundle<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.vogella.com/tutorials/android.html" target="_blank" title="Vogella">Vogella</a>
            
          </li>
        
    </ul>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=2338582935&verifier=59b78413&dpc=1"></iframe>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> louis.chen,student of USTC,Focus on mobile develop. <br/>
			It is my amibition to make beautiful apps.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2338582935" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/leerduo" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="louis.chen">louis.chen</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"chenlouis"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F63c029dba1e367df2c8ffa39a309056a' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
