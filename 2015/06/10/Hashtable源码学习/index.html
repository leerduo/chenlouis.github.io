
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Hashtable源码学习 | louis.chen</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="louis.chen">
    

    
    <meta name="description" content="Hashtable也是Map接口的实现类，Hashtable和HashMap的关系类似于ArrayList和Vector的关系。但是java8改进了HashMap的实现，使用HashMap存在key冲突时依然具有较好的性能。其次Hashtable是一个线程安全的类，而且他不允许使用null作为key和value.">
<meta property="og:type" content="article">
<meta property="og:title" content="Hashtable源码学习">
<meta property="og:url" content="http://chenfuduo.me/2015/06/10/Hashtable源码学习/index.html">
<meta property="og:site_name" content="louis.chen">
<meta property="og:description" content="Hashtable也是Map接口的实现类，Hashtable和HashMap的关系类似于ArrayList和Vector的关系。但是java8改进了HashMap的实现，使用HashMap存在key冲突时依然具有较好的性能。其次Hashtable是一个线程安全的类，而且他不允许使用null作为key和value.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hashtable源码学习">
<meta name="twitter:description" content="Hashtable也是Map接口的实现类，Hashtable和HashMap的关系类似于ArrayList和Vector的关系。但是java8改进了HashMap的实现，使用HashMap存在key冲突时依然具有较好的性能。其次Hashtable是一个线程安全的类，而且他不允许使用null作为key和value.">

    
    <link rel="alternative" href="/atom.xml" title="louis.chen" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="louis.chen" title="louis.chen"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="louis.chen">louis.chen</a></h1>
				<h2 class="blog-motto">纸上得来终觉浅,绝知此事要躬行。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/project">项目</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:chenfuduo.me">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/06/10/Hashtable源码学习/" title="Hashtable源码学习" itemprop="url">Hashtable源码学习</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="louis.chen" target="_blank" itemprop="author">louis.chen</a>
		
  <p class="article-time">
    <time datetime="2015-06-10T01:12:59.000Z" itemprop="datePublished"> 发表于 2015-06-10</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开头的注释"><span class="toc-number">1.</span> <span class="toc-text">开头的注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总体"><span class="toc-number">2.</span> <span class="toc-text">总体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#容量机制"><span class="toc-number">3.</span> <span class="toc-text">容量机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#克隆"><span class="toc-number">4.</span> <span class="toc-text">克隆</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#判空和映射的数量"><span class="toc-number">5.</span> <span class="toc-text">判空和映射的数量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#返回指定的key"><span class="toc-number">6.</span> <span class="toc-text">返回指定的key</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#是否包含key和value"><span class="toc-number">7.</span> <span class="toc-text">是否包含key和value</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#确保hash表有足够的容量"><span class="toc-number">8.</span> <span class="toc-text">确保hash表有足够的容量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rehash"><span class="toc-number">9.</span> <span class="toc-text">rehash</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建新的hash表"><span class="toc-number">10.</span> <span class="toc-text">创建新的hash表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#移除指定key的映射"><span class="toc-number">11.</span> <span class="toc-text">移除指定key的映射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#返回Key组成的集合"><span class="toc-number">12.</span> <span class="toc-text">返回Key组成的集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#返回当前map中所有value的collection集合"><span class="toc-number">13.</span> <span class="toc-text">返回当前map中所有value的collection集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#返回当前map中所有映射的set"><span class="toc-number">14.</span> <span class="toc-text">返回当前map中所有映射的set</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#elements方法"><span class="toc-number">15.</span> <span class="toc-text">elements方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#链表结点的数据结构"><span class="toc-number">16.</span> <span class="toc-text">链表结点的数据结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#迭代器相关"><span class="toc-number">17.</span> <span class="toc-text">迭代器相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#是否包含映射"><span class="toc-number">18.</span> <span class="toc-text">是否包含映射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#移除映射"><span class="toc-number">19.</span> <span class="toc-text">移除映射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写的equals、hashCode()和toString()方法"><span class="toc-number">20.</span> <span class="toc-text">重写的equals、hashCode()和toString()方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#KeySet、Values、EntrySet类"><span class="toc-number">21.</span> <span class="toc-text">KeySet、Values、EntrySet类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#序列化"><span class="toc-number">22.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">23.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码"><span class="toc-number">24.</span> <span class="toc-text">源码</span></a></li></ol>
		
		</div>
		
		<p>Hashtable也是Map接口的实现类，Hashtable和HashMap的关系类似于ArrayList和Vector的关系。但是java8改进了HashMap的实现，使用HashMap存在key冲突时依然具有较好的性能。其次Hashtable是一个线程安全的类，而且他不允许使用null作为key和value.<br><a id="more"></a></p>
<h1 id="开头的注释">开头的注释</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line"> * Hashtable is a synchronized implementation of &#123;@link Map&#125;. All optional operations are supported.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Neither keys nor values can be null. (Use &#123;@code HashMap&#125; or &#123;@code LinkedHashMap&#125; if you</span><br><span class="line"> * need null keys or values.)</span><br><span class="line"> *</span><br><span class="line"> *<span class="javadoctag"> @param</span> &lt;K&gt; the type of keys maintained by this map</span><br><span class="line"> *<span class="javadoctag"> @param</span> &lt;V&gt; the type of mapped values</span><br><span class="line"> *<span class="javadoctag"> @see</span> HashMap</span><br><span class="line"> */</span></span><br></pre></td></tr></table></figure>
<p>大体就是说：<br>Hashtable是Map接口的同步实现，所有的操作都支持。<br>不允许null作为Key或者value。</p>
<h1 id="总体">总体</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到Hashtable是继承自抽象类<code>Dictionary</code>，这个类现在已经过时了，不推荐使用。其次其实现了Cloneable和Serializable接口。</p>
<h1 id="容量机制">容量机制</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">    * Min capacity (other than zero) for a Hashtable. Must be a power of two</span><br><span class="line">    * greater than 1 (and less than 1 &lt;&lt; 30).</span><br><span class="line"> * Hashtable的最小容量值，必须是2的整数次方，且大于1，小于1&lt;&lt;30(左移30位)</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MINIMUM_CAPACITY = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * Max capacity for a Hashtable. Must be a power of two &gt;= MINIMUM_CAPACITY.</span><br><span class="line"> * 最大的容量</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * An empty table shared by all zero-capacity maps (typically from default</span><br><span class="line">    * constructor). It is never written to, and replaced on first put. Its size</span><br><span class="line">    * is set to half the minimum, so that the first resize will create a</span><br><span class="line">    * minimum-sized table.</span><br><span class="line"> * 和HashMap一模一样</span><br><span class="line"> * 一个被0容量Map共享的空表（一般是默认构造函数创建的Map）。这个表不会被写入数据，因为它会在</span><br><span class="line">    * 第一次进行put操作的时候被替换。该表的大小被设为最小值的一半（2），这样第一次增容的时候就会创建一个</span><br><span class="line">    * 最小容量的表了。</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Entry[] EMPTY_TABLE</span><br><span class="line">           = <span class="keyword">new</span> HashtableEntry[MINIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * The default load factor. Note that this implementation ignores the</span><br><span class="line">    * load factor, but cannot do away with it entirely because it's</span><br><span class="line">    * mentioned in the API.</span><br><span class="line">    *</span><br><span class="line">    * &lt;p&gt;Note that this constant has no impact on the behavior of the program,</span><br><span class="line">    * but it is emitted as part of the serialized form. The load factor of</span><br><span class="line">    * .75 is hardwired into the program, which uses cheap shifts in place of</span><br><span class="line">    * expensive division.</span><br><span class="line"> * 默认的负载因子，当Hashtable中的Entry数量与hash表长度的比值超过负载因子的时候，</span><br><span class="line">    * 将会进行rehash操作，以获取hash表容量的翻倍。</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">.75F</span>;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * The hash table.</span><br><span class="line"> * hash表，存储HashMapEntry的数组，不包括键为null的键值对。</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> HashtableEntry&lt;K, V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * The number of mappings in this hash map.</span><br><span class="line"> * Hashtable中映射的数量</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * Incremented by "structural modifications" to allow (best effort)</span><br><span class="line">    * detection of concurrent modification.</span><br><span class="line"> * 记录Hashtable中结构性修改的次数（添加或者移除键值对），以便在多线程访问时进行fail－fast判断。</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * The table is rehashed when its size exceeds this threshold.</span><br><span class="line">    * The value of this field is generally .75 * capacity, except when</span><br><span class="line">    * the capacity is zero, as described in the EMPTY_TABLE declaration</span><br><span class="line">    * above.</span><br><span class="line"> * 一个阀值，当Entry数量（size）达到该值的时候，将进行rehash操作进行增容。</span><br><span class="line">    * 该值为Hashtable容量＊负载因子。</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Views - lazily initialized</span></span><br><span class="line"><span class="comment">//懒加载的视图，在返回的时候才会创建</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;K&gt; keySet;<span class="comment">//所有key的set</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Entry&lt;K, V&gt;&gt; entrySet;<span class="comment">//所有Entry的Set</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> Collection&lt;V&gt; values;<span class="comment">//所有value的Collection</span></span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * Constructs a new &#123;@code Hashtable&#125; using the default capacity and load</span><br><span class="line">    * factor.</span><br><span class="line"> * 创建一个新的Hashtable实例，为空</span><br><span class="line">    */</span></span><br><span class="line">   <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       table = (HashtableEntry&lt;K, V&gt;[]) EMPTY_TABLE;</span><br><span class="line">	<span class="comment">//第一次put的时候由于size超过该值，将会强制进行rehash操作</span></span><br><span class="line">       threshold = -<span class="number">1</span>; <span class="comment">// Forces first put invocation to replace EMPTY_TABLE</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * Constructs a new &#123;@code Hashtable&#125; using the specified capacity and the</span><br><span class="line">    * default load factor.</span><br><span class="line">    * 根据指定的容量创建Hashtable实例</span><br><span class="line"> * 首先会判断指定的值是否在Hashtable的容量范围之内，</span><br><span class="line">    * 然后根据该值来获取一个最接近的2的n次方的数值来创建新的hash表。</span><br><span class="line">    *<span class="javadoctag"> @param</span> capacity</span><br><span class="line">    *            the initial capacity.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Capacity: "</span> + capacity);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">           HashtableEntry&lt;K, V&gt;[] tab = (HashtableEntry&lt;K, V&gt;[]) EMPTY_TABLE;</span><br><span class="line">           table = tab;</span><br><span class="line">           threshold = -<span class="number">1</span>; <span class="comment">// Forces first put() to replace EMPTY_TABLE</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (capacity &lt; MINIMUM_CAPACITY) &#123;</span><br><span class="line">           capacity = MINIMUM_CAPACITY;</span><br><span class="line">       &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(capacity &gt; MAXIMUM_CAPACITY)</span> </span>&#123;</span><br><span class="line">           capacity = MAXIMUM_CAPACITY;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           capacity = Collections.roundUpToPowerOfTwo(capacity);</span><br><span class="line">       &#125;</span><br><span class="line">       makeTable(capacity);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * Constructs a new &#123;@code Hashtable&#125; using the specified capacity and load</span><br><span class="line">    * factor.</span><br><span class="line">    * 根据指定的容量和负载因子创建一个Hashtable实例。</span><br><span class="line">    * 方法中传入的负载因子被忽略了，并没有使用，因此没有意义。</span><br><span class="line">    *<span class="javadoctag"> @param</span> capacity</span><br><span class="line">    *            the initial capacity.</span><br><span class="line">    *<span class="javadoctag"> @param</span> loadFactor</span><br><span class="line">    *            the initial load factor.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(capacity);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Load factor: "</span> + loadFactor);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span><br><span class="line">        * Note that this implementation ignores loadFactor; it always uses</span><br><span class="line">        * a load factor of 3/4. This simplifies the code and generally</span><br><span class="line">        * improves performance.</span><br><span class="line">        */</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * Constructs a new instance of &#123;@code Hashtable&#125; containing the mappings</span><br><span class="line">    * from the specified map.</span><br><span class="line">    * 根据指定的Map对象来创建一个Hashtable实例。</span><br><span class="line">    *<span class="javadoctag"> @param</span> map</span><br><span class="line">    *            the mappings to add.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(capacityForInitSize(map.size()));</span><br><span class="line">       constructorPutAll(map);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * Inserts all of the elements of map into this Hashtable in a manner</span><br><span class="line">    * suitable for use by constructors and pseudo-constructors (i.e., clone,</span><br><span class="line">    * readObject).</span><br><span class="line"> * 将Map中的所有元素添加到该元素中，</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">constructorPutAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">           doubleCapacity(); <span class="comment">// Don't do unchecked puts to a shared table.</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;? extends K, ? extends V&gt; e : map.entrySet()) &#123;</span><br><span class="line">           constructorPut(e.getKey(), e.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * Returns an appropriate capacity for the specified initial size. Does</span><br><span class="line">    * not round the result up to a power of two; the caller must do this!</span><br><span class="line">    * The returned value will be between 0 and MAXIMUM_CAPACITY (inclusive).</span><br><span class="line"> * 根据指定的初始值来获取一个容量，一般会为初始值的1.5倍，</span><br><span class="line">    * 该方法不会获取一个2的n次方的数值，需要调用者自己处理。</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">capacityForInitSize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result = (size &gt;&gt; <span class="number">1</span>) + size; <span class="comment">// Multiply by 3/2 to allow for growth</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// boolean expr is equivalent to result &gt;= 0 &amp;&amp; result&lt;MAXIMUM_CAPACITY</span></span><br><span class="line">       <span class="keyword">return</span> (result &amp; ~(MAXIMUM_CAPACITY-<span class="number">1</span>))==<span class="number">0</span> ? result : MAXIMUM_CAPACITY;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="克隆">克隆</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">    * Returns a new &#123;@code Hashtable&#125; with the same key/value pairs, capacity</span><br><span class="line">    * and load factor.</span><br><span class="line">    * </span><br><span class="line">    *<span class="javadoctag"> @return</span> a shallow copy of this &#123;@code Hashtable&#125;.</span><br><span class="line">    *<span class="javadoctag"> @see</span> java.lang.Cloneable</span><br><span class="line">    */</span></span><br><span class="line">   <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span><br><span class="line">        * This could be made more efficient. It unnecessarily hashes all of</span><br><span class="line">        * the elements in the map.</span><br><span class="line">        */</span></span><br><span class="line">       Hashtable&lt;K, V&gt; result;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           result = (Hashtable&lt;K, V&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Restore clone to empty state, retaining our capacity and threshold</span></span><br><span class="line">       result.makeTable(table.length);</span><br><span class="line">       result.size = <span class="number">0</span>;</span><br><span class="line">       result.keySet = <span class="keyword">null</span>;</span><br><span class="line">       result.entrySet = <span class="keyword">null</span>;</span><br><span class="line">       result.values = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       result.constructorPutAll(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="判空和映射的数量">判空和映射的数量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">    * Returns true if this &#123;@code Hashtable&#125; has no key/value pairs.</span><br><span class="line">    * 返回当前Hashtable是否为空，映射数量为0.</span><br><span class="line">    *<span class="javadoctag"> @return</span> &#123;@code true&#125; if this &#123;@code Hashtable&#125; has no key/value pairs,</span><br><span class="line">    *         &#123;@code false&#125; otherwise.</span><br><span class="line">    *<span class="javadoctag"> @see</span> #size</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * Returns the number of key/value pairs in this &#123;@code Hashtable&#125;.</span><br><span class="line">    * 返回当前Hashtable中映射的数量。</span><br><span class="line">    *<span class="javadoctag"> @return</span> the number of key/value pairs in this &#123;@code Hashtable&#125;.</span><br><span class="line">    *<span class="javadoctag"> @see</span> #elements</span><br><span class="line">    *<span class="javadoctag"> @see</span> #keys</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> size;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="返回指定的key">返回指定的key</h1><p>这里省去了key为null的判断，因为它的key不能为null<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">   * Returns the value associated with the specified key in this</span><br><span class="line">   * &#123;@code Hashtable&#125;.</span><br><span class="line">   * 返回指定key的值，如果没有该key的映射存在，返回null。</span><br><span class="line">* 根据key的hash值查找hash表的位置，遍历该位置上的Entry链，返回该key的值。</span><br><span class="line">   *<span class="javadoctag"> @param</span> key</span><br><span class="line">   *            the key of the value returned.</span><br><span class="line">   *<span class="javadoctag"> @return</span> the value associated with the specified key, or &#123;@code null&#125; if</span><br><span class="line">   *         the specified key does not exist.</span><br><span class="line">   *<span class="javadoctag"> @see</span> #put</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> hash = Collections.secondaryHash(key);</span><br><span class="line">      HashtableEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">      <span class="keyword">for</span> (HashtableEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - <span class="number">1</span>)];</span><br><span class="line">              e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">          K eKey = e.key;</span><br><span class="line">          <span class="keyword">if</span> (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123;</span><br><span class="line">              <span class="keyword">return</span> e.value;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="是否包含key和value">是否包含key和value</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="javadoc">/**</span><br><span class="line">     * Returns true if this &#123;@code Hashtable&#125; contains the specified object as a</span><br><span class="line">     * key of one of the key/value pairs.</span><br><span class="line">     * 返回当前Hashtable是否包含指定的key。</span><br><span class="line">     * 类似get方法，但是不返回value。</span><br><span class="line">     *<span class="javadoctag"> @param</span> key</span><br><span class="line">     *            the object to look for as a key in this &#123;@code Hashtable&#125;.</span><br><span class="line">     *<span class="javadoctag"> @return</span> &#123;@code true&#125; if object is a key in this &#123;@code Hashtable&#125;,</span><br><span class="line">     *         &#123;@code false&#125; otherwise.</span><br><span class="line">     *<span class="javadoctag"> @see</span> #contains</span><br><span class="line">     *<span class="javadoctag"> @see</span> java.lang.Object#equals</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = Collections.secondaryHash(key);</span><br><span class="line">        HashtableEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (HashtableEntry&lt;K, V&gt; e = tab[hash &amp; (tab.length - <span class="number">1</span>)];</span><br><span class="line">                e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            K eKey = e.key;</span><br><span class="line">            <span class="keyword">if</span> (eKey == key || (e.hash == hash &amp;&amp; key.equals(eKey))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="javadoc">/**</span><br><span class="line">     * Searches this &#123;@code Hashtable&#125; for the specified value.</span><br><span class="line">     * 返回当前的Hashtable是否包含指定的value。</span><br><span class="line">     * 遍历Hashtable，将每个value与指定value比较。</span><br><span class="line">     *<span class="javadoctag"> @param</span> value</span><br><span class="line">     *            the object to search for.</span><br><span class="line">     *<span class="javadoctag"> @return</span> &#123;@code true&#125; if &#123;@code value&#125; is a value of this</span><br><span class="line">     *         &#123;@code Hashtable&#125;, &#123;@code false&#125; otherwise.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"value == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashtableEntry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (HashtableEntry e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (value.equals(e.value)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="javadoc">/**</span><br><span class="line">     * Returns true if this &#123;@code Hashtable&#125; contains the specified object as</span><br><span class="line">     * the value of at least one of the key/value pairs.</span><br><span class="line">     *</span><br><span class="line">     *<span class="javadoctag"> @param</span> value</span><br><span class="line">     *            the object to look for as a value in this &#123;@code Hashtable&#125;.</span><br><span class="line">     *<span class="javadoctag"> @return</span> &#123;@code true&#125; if object is a value in this &#123;@code Hashtable&#125;,</span><br><span class="line">     *         &#123;@code false&#125; otherwise.</span><br><span class="line">     *<span class="javadoctag"> @see</span> #containsKey</span><br><span class="line">     *<span class="javadoctag"> @see</span> java.lang.Object#equals</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> containsValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">```	</span><br><span class="line">#创建一个指定key和value添加到HashMap中</span><br><span class="line">```java</span><br><span class="line">  <span class="javadoc">/**</span><br><span class="line">     * Associate the specified value with the specified key in this</span><br><span class="line">     * &#123;@code Hashtable&#125;. If the key already exists, the old value is replaced.</span><br><span class="line">     * The key and value cannot be null.</span><br><span class="line">     * 创建一个指定的key和value映射添加到HashMap中。</span><br><span class="line">     * 如果HashMap中包含指定key的映射，那么将修改映射的值，并将原值返回</span><br><span class="line">	 * key/value不能为null，否则抛出空指针异常</span><br><span class="line">     *<span class="javadoctag"> @param</span> key</span><br><span class="line">     *            the key to add.</span><br><span class="line">     *<span class="javadoctag"> @param</span> value</span><br><span class="line">     *            the value to add.</span><br><span class="line">     *<span class="javadoctag"> @return</span> the old value associated with the specified key, or &#123;@code null&#125;</span><br><span class="line">     *         if the key did not exist.</span><br><span class="line">     *<span class="javadoctag"> @see</span> #elements</span><br><span class="line">     *<span class="javadoctag"> @see</span> #get</span><br><span class="line">     *<span class="javadoctag"> @see</span> #keys</span><br><span class="line">     *<span class="javadoctag"> @see</span> java.lang.Object#equals</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(value == <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"value == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hash = Collections.secondaryHash(key);</span><br><span class="line">        HashtableEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        HashtableEntry&lt;K, V&gt; first = tab[index];</span><br><span class="line">        <span class="keyword">for</span> (HashtableEntry&lt;K, V&gt; e = first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// No entry for key is present; create one</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size++ &gt; threshold) &#123;</span><br><span class="line">            rehash();  <span class="comment">// Does nothing!!</span></span><br><span class="line">            tab = doubleCapacity();</span><br><span class="line">            index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">            first = tab[index];</span><br><span class="line">        &#125;</span><br><span class="line">        tab[index] = <span class="keyword">new</span> HashtableEntry&lt;K, V&gt;(key, value, hash, first);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="javadoc">/**</span><br><span class="line">     * This method is just like put, except that it doesn't do things that</span><br><span class="line">     * are inappropriate or unnecessary for constructors and pseudo-constructors</span><br><span class="line">     * (i.e., clone, readObject). In particular, this method does not check to</span><br><span class="line">     * ensure that capacity is sufficient, and does not increment modCount.</span><br><span class="line">	 * 该方法不去检查容量是否足够，不去增加modCount的值</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">constructorPut</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(value == <span class="keyword">null</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"value == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> hash = Collections.secondaryHash(key);</span><br><span class="line">        HashtableEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">        HashtableEntry&lt;K, V&gt; first = tab[index];</span><br><span class="line">        <span class="keyword">for</span> (HashtableEntry&lt;K, V&gt; e = first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// No entry for key is present; create one</span></span><br><span class="line">        tab[index] = <span class="keyword">new</span> HashtableEntry&lt;K, V&gt;(key, value, hash, first);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="javadoc">/**</span><br><span class="line">     * Copies every mapping to this &#123;@code Hashtable&#125; from the specified map.</span><br><span class="line">     * 从指定的map中将每一个映射拷贝到当前的Hashtable</span><br><span class="line">     *<span class="javadoctag"> @param</span> map</span><br><span class="line">     *            the map to copy mappings from.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> </span>&#123;</span><br><span class="line">        ensureCapacity(map.size());</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;? extends K, ? extends V&gt; e : map.entrySet()) &#123;</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="确保hash表有足够的容量">确保hash表有足够的容量</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">   * Ensures that the hash table has sufficient capacity to store the</span><br><span class="line">   * specified number of mappings, with room to grow. If not, it increases the</span><br><span class="line">   * capacity as appropriate. Like doubleCapacity, this method moves existing</span><br><span class="line">   * entries to new buckets as appropriate. Unlike doubleCapacity, this method</span><br><span class="line">   * can grow the table by factors of 2^n for n &gt; 1. Hopefully, a single call</span><br><span class="line">   * to this method will be faster than multiple calls to doubleCapacity.</span><br><span class="line">   * 确保hash表有足够的容量来存储指定数目的映射。</span><br><span class="line">   * 该方法增长的容量不一定是翻倍。</span><br><span class="line">   * 该方法仅被putAll方法调用。</span><br><span class="line">   *  &lt;p&gt;This method is called only by putAll.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> numMappings)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> newCapacity = Collections.roundUpToPowerOfTwo(capacityForInitSize(numMappings));</span><br><span class="line">      HashtableEntry&lt;K, V&gt;[] oldTable = table;</span><br><span class="line">      <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">      <span class="keyword">if</span> (newCapacity &lt;= oldCapacity) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      rehash();  <span class="comment">// Does nothing!!</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newCapacity == oldCapacity * <span class="number">2</span>) &#123;</span><br><span class="line">          doubleCapacity();</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We're growing by at least 4x, rehash in the obvious way</span></span><br><span class="line">      HashtableEntry&lt;K, V&gt;[] newTable = makeTable(newCapacity);</span><br><span class="line">      <span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> newMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity; i++) &#123;</span><br><span class="line">              <span class="keyword">for</span> (HashtableEntry&lt;K, V&gt; e = oldTable[i]; e != <span class="keyword">null</span>;) &#123;</span><br><span class="line">                  HashtableEntry&lt;K, V&gt; oldNext = e.next;</span><br><span class="line">                  <span class="keyword">int</span> newIndex = e.hash &amp; newMask;</span><br><span class="line">                  HashtableEntry&lt;K, V&gt; newNext = newTable[newIndex];</span><br><span class="line">                  newTable[newIndex] = e;</span><br><span class="line">                  e.next = newNext;</span><br><span class="line">                  e = oldNext;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="rehash">rehash</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">    * Increases the capacity of this &#123;@code Hashtable&#125;. This method is called</span><br><span class="line">    * when the size of this &#123;@code Hashtable&#125; exceeds the load factor.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span><br><span class="line">        * This method has no testable semantics, other than that it gets</span><br><span class="line">        * called from time to time.</span><br><span class="line">        */</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="创建新的hash表">创建新的hash表</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">    * Allocate a table of the given capacity and set the threshold accordingly.</span><br><span class="line">    *<span class="javadoctag"> @param</span> newCapacity must be a power of two</span><br><span class="line"> * 根据指定的容量创建一个新的hash表，并设定负载阀值。</span><br><span class="line">    * 指定的容量必须是2的n次方。</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">private</span> HashtableEntry&lt;K, V&gt;[] makeTable(<span class="keyword">int</span> newCapacity) &#123;</span><br><span class="line">       <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) HashtableEntry&lt;K, V&gt;[] newTable</span><br><span class="line">               = (HashtableEntry&lt;K, V&gt;[]) <span class="keyword">new</span> HashtableEntry[newCapacity];</span><br><span class="line">       table = newTable;</span><br><span class="line">       threshold = (newCapacity &gt;&gt; <span class="number">1</span>) + (newCapacity &gt;&gt; <span class="number">2</span>); <span class="comment">// 3/4 capacity</span></span><br><span class="line">       <span class="keyword">return</span> newTable;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * Doubles the capacity of the hash table. Existing entries are placed in</span><br><span class="line">    * the correct bucket on the enlarged table. If the current capacity is,</span><br><span class="line">    * MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which</span><br><span class="line">    * will be new unless we were already at MAXIMUM_CAPACITY.</span><br><span class="line"> * 将当前hash表的容量翻倍. 现有的映射都将被移入新表的正确位置.</span><br><span class="line">    * 如果当前表的容量为最大值，该方法不做操作.</span><br><span class="line">    * 返回新建的表，如果当前容量不是最大值的话.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">private</span> HashtableEntry&lt;K, V&gt;[] doubleCapacity() &#123;</span><br><span class="line">       HashtableEntry&lt;K, V&gt;[] oldTable = table;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">       <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           <span class="keyword">return</span> oldTable;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> newCapacity = oldCapacity * <span class="number">2</span>;</span><br><span class="line">       HashtableEntry&lt;K, V&gt;[] newTable = makeTable(newCapacity);</span><br><span class="line">       <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> newTable;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCapacity; j++) &#123;</span><br><span class="line">           <span class="comment">/*</span><br><span class="line">            * Rehash the bucket using the minimum number of field writes.</span><br><span class="line">            * This is the most subtle and delicate code in the class.</span><br><span class="line">            */</span></span><br><span class="line">           HashtableEntry&lt;K, V&gt; e = oldTable[j];</span><br><span class="line">           <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> highBit = e.hash &amp; oldCapacity;</span><br><span class="line">           HashtableEntry&lt;K, V&gt; broken = <span class="keyword">null</span>;</span><br><span class="line">           newTable[j | highBit] = e;</span><br><span class="line">           <span class="keyword">for</span> (HashtableEntry&lt;K,V&gt; n = e.next; n != <span class="keyword">null</span>; e = n, n = n.next) &#123;</span><br><span class="line">               <span class="keyword">int</span> nextHighBit = n.hash &amp; oldCapacity;</span><br><span class="line">               <span class="keyword">if</span> (nextHighBit != highBit) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (broken == <span class="keyword">null</span>)</span><br><span class="line">                       newTable[j | nextHighBit] = n;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       broken.next = n;</span><br><span class="line">                   broken = e;</span><br><span class="line">                   highBit = nextHighBit;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (broken != <span class="keyword">null</span>)</span><br><span class="line">               broken.next = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTable;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="移除指定key的映射">移除指定key的映射</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">    * Removes the key/value pair with the specified key from this</span><br><span class="line">    * &#123;@code Hashtable&#125;.</span><br><span class="line">    * 移除指定key的映射。</span><br><span class="line">    * 返回key的映射值，如果该映射不存在的话返回null。</span><br><span class="line">    *<span class="javadoctag"> @param</span> key</span><br><span class="line">    *            the key to remove.</span><br><span class="line">    *<span class="javadoctag"> @return</span> the value associated with the specified key, or &#123;@code null&#125; if</span><br><span class="line">    *         the specified key did not exist.</span><br><span class="line">    *<span class="javadoctag"> @see</span> #get</span><br><span class="line">    *<span class="javadoctag"> @see</span> #put</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> hash = Collections.secondaryHash(key);</span><br><span class="line">       HashtableEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">       <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (HashtableEntry&lt;K, V&gt; e = tab[index], prev = <span class="keyword">null</span>;</span><br><span class="line">               e != <span class="keyword">null</span>; prev = e, e = e.next) &#123;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   tab[index] = e.next;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   prev.next = e.next;</span><br><span class="line">               &#125;</span><br><span class="line">               modCount++;</span><br><span class="line">               size--;</span><br><span class="line">               <span class="keyword">return</span> e.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * Removes all key/value pairs from this &#123;@code Hashtable&#125;, leaving the</span><br><span class="line">    * size zero and the capacity unchanged.</span><br><span class="line">    * 移除所有的键值对，之后保持映射的大小为0，容量不变</span><br><span class="line">    *<span class="javadoctag"> @see</span> #isEmpty</span><br><span class="line">    *<span class="javadoctag"> @see</span> #size</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">           Arrays.fill(table, <span class="keyword">null</span>);</span><br><span class="line">           modCount++;</span><br><span class="line">           size = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="返回Key组成的集合">返回Key组成的集合</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">    * Returns a set of the keys contained in this &#123;@code Hashtable&#125;. The set</span><br><span class="line">    * is backed by this &#123;@code Hashtable&#125; so changes to one are reflected by</span><br><span class="line">    * the other. The set does not support adding.</span><br><span class="line">    * 返回当前map中所有key的set集合。set和map会互相影响，set不支持添加。</span><br><span class="line">    *<span class="javadoctag"> @return</span> a set of the keys.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Set&lt;K&gt; ks = keySet;</span><br><span class="line">       <span class="keyword">return</span> (ks != <span class="keyword">null</span>) ? ks : (keySet = <span class="keyword">new</span> KeySet());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="返回当前map中所有value的collection集合">返回当前map中所有value的collection集合</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">    * Returns a collection of the values contained in this &#123;@code Hashtable&#125;.</span><br><span class="line">    * The collection is backed by this &#123;@code Hashtable&#125; so changes to one are</span><br><span class="line">    * reflected by the other. The collection does not support adding.</span><br><span class="line">    * 返回当前map中所有value的collection集合。collection和map会互相影响。</span><br><span class="line">    * collection不支持add方法。</span><br><span class="line">    *<span class="javadoctag"> @return</span> a collection of the values.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Collection&lt;V&gt; vs = values;</span><br><span class="line">       <span class="keyword">return</span> (vs != <span class="keyword">null</span>) ? vs : (values = <span class="keyword">new</span> Values());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="返回当前map中所有映射的set">返回当前map中所有映射的set</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">    * Returns a set of the mappings contained in this &#123;@code Hashtable&#125;. Each</span><br><span class="line">    * element in the set is a &#123;@link Map.Entry&#125;. The set is backed by this</span><br><span class="line">    * &#123;@code Hashtable&#125; so changes to one are reflected by the other. The set</span><br><span class="line">    * does not support adding.</span><br><span class="line">    *</span><br><span class="line">    *<span class="javadoctag"> @return</span> a set of the mappings.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> Set&lt;Entry&lt;K, V&gt;&gt; entrySet() &#123;</span><br><span class="line">       Set&lt;Entry&lt;K, V&gt;&gt; es = entrySet;</span><br><span class="line">       <span class="keyword">return</span> (es != <span class="keyword">null</span>) ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="elements方法">elements方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">    * Returns an enumeration on the values of this &#123;@code Hashtable&#125;. The</span><br><span class="line">    * results of the Enumeration may be affected if the contents of this</span><br><span class="line">    * &#123;@code Hashtable&#125; are modified.</span><br><span class="line">    *</span><br><span class="line">    *<span class="javadoctag"> @return</span> an enumeration of the values of this &#123;@code Hashtable&#125;.</span><br><span class="line">    *<span class="javadoctag"> @see</span> #keys</span><br><span class="line">    *<span class="javadoctag"> @see</span> #size</span><br><span class="line">    *<span class="javadoctag"> @see</span> Enumeration</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ValueEnumeration();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法现在很少用，当时还没有Map接口，所以提供了这个方法。</p>
<h1 id="链表结点的数据结构">链表结点的数据结构</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">     * Note: technically the methods of this class should synchronize the</span><br><span class="line">     * backing map.  However, this would require them to have a reference</span><br><span class="line">     * to it, which would cause considerable bloat.  Moreover, the RI</span><br><span class="line">     * behaves the same way.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HashtableEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        HashtableEntry&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">        HashtableEntry(K key, V value, <span class="keyword">int</span> hash, HashtableEntry&lt;K, V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"value == null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Entry)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) o;</span><br><span class="line">            <span class="keyword">return</span> key.equals(e.getKey()) &amp;&amp; value.equals(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key.hashCode() ^ value.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这部分的数据结构和HashMap的一样。</p>
<h1 id="迭代器相关">迭代器相关</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nextIndex;</span><br><span class="line">        HashtableEntry&lt;K, V&gt; nextEntry;</span><br><span class="line">        HashtableEntry&lt;K, V&gt; lastEntryReturned;</span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            HashtableEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">            HashtableEntry&lt;K, V&gt; next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (next == <span class="keyword">null</span> &amp;&amp; nextIndex &lt; tab.length) &#123;</span><br><span class="line">                next = tab[nextIndex++];</span><br><span class="line">            &#125;</span><br><span class="line">            nextEntry = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextEntry != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashtableEntry&lt;K, V&gt; nextEntry() &#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            <span class="keyword">if</span> (nextEntry == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">            HashtableEntry&lt;K, V&gt; entryToReturn = nextEntry;</span><br><span class="line">            HashtableEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">            HashtableEntry&lt;K, V&gt; next = entryToReturn.next;</span><br><span class="line">            <span class="keyword">while</span> (next == <span class="keyword">null</span> &amp;&amp; nextIndex &lt; tab.length) &#123;</span><br><span class="line">                next = tab[nextIndex++];</span><br><span class="line">            &#125;</span><br><span class="line">            nextEntry = next;</span><br><span class="line">            <span class="keyword">return</span> lastEntryReturned = entryToReturn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashtableEntry&lt;K, V&gt; nextEntryNotFailFast() &#123;</span><br><span class="line">            <span class="keyword">if</span> (nextEntry == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">            HashtableEntry&lt;K, V&gt; entryToReturn = nextEntry;</span><br><span class="line">            HashtableEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">            HashtableEntry&lt;K, V&gt; next = entryToReturn.next;</span><br><span class="line">            <span class="keyword">while</span> (next == <span class="keyword">null</span> &amp;&amp; nextIndex &lt; tab.length) &#123;</span><br><span class="line">                next = tab[nextIndex++];</span><br><span class="line">            &#125;</span><br><span class="line">            nextEntry = next;</span><br><span class="line">            <span class="keyword">return</span> lastEntryReturned = entryToReturn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastEntryReturned == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            Hashtable.<span class="keyword">this</span>.remove(lastEntryReturned.key);</span><br><span class="line">            lastEntryReturned = <span class="keyword">null</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntry().key; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntry().value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Entry&lt;K, V&gt; next() &#123; <span class="keyword">return</span> nextEntry(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyEnumeration</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hasNext(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">nextElement</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntryNotFailFast().key; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueEnumeration</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span><br><span class="line">            <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hasNext(); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">nextElement</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntryNotFailFast().value; &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="是否包含映射">是否包含映射</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">    * Returns true if this map contains the specified mapping.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> hash = Collections.secondaryHash(key);</span><br><span class="line">       HashtableEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">       <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (HashtableEntry&lt;K, V&gt; e = tab[index]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">               <span class="keyword">return</span> e.value.equals(value);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// No entry for key</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="移除映射">移除映射</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">    * Removes the mapping from key to value and returns true if this mapping</span><br><span class="line">    * exists; otherwise, returns does nothing and returns false.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeMapping</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> hash = Collections.secondaryHash(key);</span><br><span class="line">       HashtableEntry&lt;K, V&gt;[] tab = table;</span><br><span class="line">       <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">for</span> (HashtableEntry&lt;K, V&gt; e = tab[index], prev = <span class="keyword">null</span>;</span><br><span class="line">               e != <span class="keyword">null</span>; prev = e, e = e.next) &#123;</span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!e.value.equals(value)) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// Map has wrong value for key</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   tab[index] = e.next;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   prev.next = e.next;</span><br><span class="line">               &#125;</span><br><span class="line">               modCount++;</span><br><span class="line">               size--;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// No entry for key</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="重写的equals、hashCode()和toString()方法">重写的equals、hashCode()和toString()方法</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="javadoc">/**</span><br><span class="line">    * Compares this &#123;@code Hashtable&#125; with the specified object and indicates</span><br><span class="line">    * if they are equal. In order to be equal, &#123;@code object&#125; must be an</span><br><span class="line">    * instance of Map and contain the same key/value pairs.</span><br><span class="line">    *</span><br><span class="line">    *<span class="javadoctag"> @param</span> object</span><br><span class="line">    *            the object to compare with this object.</span><br><span class="line">    *<span class="javadoctag"> @return</span> &#123;@code true&#125; if the specified object is equal to this Map,</span><br><span class="line">    *         &#123;@code false&#125; otherwise.</span><br><span class="line">    *<span class="javadoctag"> @see</span> #hashCode</span><br><span class="line">    */</span></span><br><span class="line">   <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (object <span class="keyword">instanceof</span> Map) &amp;&amp;</span><br><span class="line">               entrySet().equals(((Map&lt;?, ?&gt;)object).entrySet());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (Entry&lt;K, V&gt; e : entrySet()) &#123;</span><br><span class="line">           K key = e.getKey();</span><br><span class="line">           V value = e.getValue();</span><br><span class="line">           <span class="keyword">if</span> (key == <span class="keyword">this</span> || value == <span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           result += (key != <span class="keyword">null</span> ? key.hashCode() : <span class="number">0</span>)</span><br><span class="line">                   ^ (value != <span class="keyword">null</span> ? value.hashCode() : <span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="javadoc">/**</span><br><span class="line">    * A rough estimate of the number of characters per entry, for use</span><br><span class="line">    * when creating a string buffer in the toString method.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHARS_PER_ENTRY = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">   <span class="javadoc">/**</span><br><span class="line">    * Returns the string representation of this &#123;@code Hashtable&#125;.</span><br><span class="line">    *</span><br><span class="line">    *<span class="javadoctag"> @return</span> the string representation of this &#123;@code Hashtable&#125;.</span><br><span class="line">    */</span></span><br><span class="line">   <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       StringBuilder result = <span class="keyword">new</span> StringBuilder(CHARS_PER_ENTRY * size);</span><br><span class="line">       result.append(<span class="string">'&#123;'</span>);</span><br><span class="line">       Iterator&lt;Entry&lt;K, V&gt;&gt; i = entrySet().iterator();</span><br><span class="line">       <span class="keyword">boolean</span> hasMore = i.hasNext();</span><br><span class="line">       <span class="keyword">while</span> (hasMore) &#123;</span><br><span class="line">           Entry&lt;K, V&gt; entry = i.next();</span><br><span class="line"></span><br><span class="line">           K key = entry.getKey();</span><br><span class="line">           result.append(key == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : key.toString());</span><br><span class="line"></span><br><span class="line">           result.append(<span class="string">'='</span>);</span><br><span class="line"></span><br><span class="line">           V value = entry.getValue();</span><br><span class="line">           result.append(value == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : value.toString());</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (hasMore = i.hasNext()) &#123;</span><br><span class="line">               result.append(<span class="string">", "</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       result.append(<span class="string">'&#125;'</span>);</span><br><span class="line">       <span class="keyword">return</span> result.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="KeySet、Values、EntrySet类">KeySet、Values、EntrySet类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Hashtable.<span class="keyword">this</span>.size();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> containsKey(o);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> oldSize = size;</span><br><span class="line">               Hashtable.<span class="keyword">this</span>.remove(o);</span><br><span class="line">               <span class="keyword">return</span> size != oldSize;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Hashtable.<span class="keyword">this</span>.clear();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.removeAll(collection);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.retainAll(collection);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.containsAll(collection);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.equals(object);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.toArray();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.toArray(a);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Hashtable.<span class="keyword">this</span>.size();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> containsValue(o);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Hashtable.<span class="keyword">this</span>.clear();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.containsAll(collection);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.toArray();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.toArray(a);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">public</span> Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Entry))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) o;</span><br><span class="line">           <span class="keyword">return</span> containsMapping(e.getKey(), e.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Entry))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;)o;</span><br><span class="line">           <span class="keyword">return</span> removeMapping(e.getKey(), e.getValue());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Hashtable.<span class="keyword">this</span>.size();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Hashtable.<span class="keyword">this</span>.clear();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.removeAll(collection);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.retainAll(collection);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.containsAll(collection);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.equals(object);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> Hashtable.<span class="keyword">this</span>.hashCode();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.toArray();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">super</span>.toArray(a);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="序列化">序列化</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1421746759512286392L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = &#123;</span><br><span class="line">      <span class="keyword">new</span> ObjectStreamField(<span class="string">"threshold"</span>, <span class="keyword">int</span>.class),</span><br><span class="line">      <span class="keyword">new</span> ObjectStreamField(<span class="string">"loadFactor"</span>, <span class="keyword">float</span>.class),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span></span><br><span class="line">          <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// Emulate loadFactor field for other implementations to read</span></span><br><span class="line">      ObjectOutputStream.PutField fields = stream.putFields();</span><br><span class="line">      fields.put(<span class="string">"threshold"</span>,  (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * table.length));</span><br><span class="line">      fields.put(<span class="string">"loadFactor"</span>, DEFAULT_LOAD_FACTOR);</span><br><span class="line">      stream.writeFields();</span><br><span class="line"></span><br><span class="line">      stream.writeInt(table.length); <span class="comment">// Capacity</span></span><br><span class="line">      stream.writeInt(size);</span><br><span class="line">      <span class="keyword">for</span> (Entry&lt;K, V&gt; e : entrySet()) &#123;</span><br><span class="line">          stream.writeObject(e.getKey());</span><br><span class="line">          stream.writeObject(e.getValue());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">          ClassNotFoundException </span>&#123;</span><br><span class="line">      stream.defaultReadObject();</span><br><span class="line">      <span class="keyword">int</span> capacity = stream.readInt();</span><br><span class="line">      <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Capacity: "</span> + capacity);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (capacity &lt; MINIMUM_CAPACITY) &#123;</span><br><span class="line">          capacity = MINIMUM_CAPACITY;</span><br><span class="line">      &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(capacity &gt; MAXIMUM_CAPACITY)</span> </span>&#123;</span><br><span class="line">          capacity = MAXIMUM_CAPACITY;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          capacity = Collections.roundUpToPowerOfTwo(capacity);</span><br><span class="line">      &#125;</span><br><span class="line">      makeTable(capacity);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> size = stream.readInt();</span><br><span class="line">      <span class="keyword">if</span> (size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Size: "</span> + size);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">          <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) K key = (K) stream.readObject();</span><br><span class="line">          <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V val = (V) stream.readObject();</span><br><span class="line">          constructorPut(key, val);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1><ul>
<li>和HashMap一样，Hashtable也是一个散列表，通过<code>拉链法</code>解决hash冲突的。<br>上述源码中链表的数据结构以及开始的数组：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashtableEntry&lt;K, V&gt;[] table;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Hashtable中的key-value都是存储在table数组中的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HashtableEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        HashtableEntry&lt;K, V&gt; next;</span><br><span class="line"></span><br><span class="line">        HashtableEntry(K key, V value, <span class="keyword">int</span> hash, HashtableEntry&lt;K, V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"value == null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            V oldValue = <span class="keyword">this</span>.value;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Entry)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) o;</span><br><span class="line">            <span class="keyword">return</span> key.equals(e.getKey()) &amp;&amp; value.equals(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key.hashCode() ^ value.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key + <span class="string">"="</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>从中，我们可以看出<code>HashtableEntry实际上就是一个单向链表</code>。这也是为什么我们说Hashtable是通过拉链法解决哈希冲突的。<br>HashtableEntry实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数。这些都是基本的读取/修改key、value值的函数。</p>
<ul>
<li>构造函数<br>和HashMap一样，Hashtable也有四个构造函数。</li>
<li>Hashtable的主要对外接口<br>clear(),contains() 和 containsValue(),containsKey(),elements(),get(),put(),putAll(),remove().</li>
<li>Hashtable实现的Cloneable接口</li>
<li>Hashtable实现的Serializable接口</li>
<li>Hashtable遍历方式<br>1.遍历Hashtable的键值对<br>第一步：根据entrySet()获取Hashtable的“键值对”的Set集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设table是Hashtable对象</span></span><br><span class="line"><span class="comment">// table中的key是String类型，value是Integer类型</span></span><br><span class="line">Integer integ = <span class="keyword">null</span>;</span><br><span class="line">Iterator iter = table.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    Map.Entry entry = (Map.Entry)iter.next();</span><br><span class="line">    <span class="comment">// 获取key</span></span><br><span class="line">    key = (String)entry.getKey();</span><br><span class="line">        <span class="comment">// 获取value</span></span><br><span class="line">    integ = (Integer)entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2.通过Iterator遍历Hashtable的键<br>第一步：根据keySet()获取Hashtable的“键”的Set集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设table是Hashtable对象</span></span><br><span class="line"><span class="comment">// table中的key是String类型，value是Integer类型</span></span><br><span class="line">String key = <span class="keyword">null</span>;</span><br><span class="line">Integer integ = <span class="keyword">null</span>;</span><br><span class="line">Iterator iter = table.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="comment">// 获取key</span></span><br><span class="line">    key = (String)iter.next();</span><br><span class="line">        <span class="comment">// 根据key，获取value</span></span><br><span class="line">    integ = (Integer)table.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.通过Iterator遍历Hashtable的值<br>第一步：根据value()获取Hashtable的“值”的集合。<br>第二步：通过Iterator迭代器遍历“第一步”得到的集合。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设table是Hashtable对象</span></span><br><span class="line"><span class="comment">// table中的key是String类型，value是Integer类型</span></span><br><span class="line">Integer value = <span class="keyword">null</span>;</span><br><span class="line">Collection c = table.values();</span><br><span class="line">Iterator iter= c.iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    value = (Integer)iter.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，Hashtable中的映射不是有序的。</li>
<li>Hashtable 的实例有两个参数影响其性能：<code>初始容量 和 加载因子</code>。(加载因子比负载因子好点)<h1 id="源码">源码</h1>```java<br>/*<ul>
<li>Licensed to the Apache Software Foundation (ASF) under one or more</li>
<li>contributor license agreements.  See the NOTICE file distributed with</li>
<li>this work for additional information regarding copyright ownership.</li>
<li>The ASF licenses this file to You under the Apache License, Version 2.0</li>
<li>(the “License”); you may not use this file except in compliance with</li>
<li>the License.  You may obtain a copy of the License at<br>*</li>
<li><a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="external">http://www.apache.org/licenses/LICENSE-2.0</a><br>*</li>
<li>Unless required by applicable law or agreed to in writing, software</li>
<li>distributed under the License is distributed on an “AS IS” BASIS,</li>
<li>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</li>
<li>See the License for the specific language governing permissions and</li>
<li>limitations under the License.<br>*/</li>
</ul>
</li>
</ul>
<p>package java.util;</p>
<p>import java.io.IOException;<br>import java.io.InvalidObjectException;<br>import java.io.ObjectInputStream;<br>import java.io.ObjectOutputStream;<br>import java.io.ObjectStreamField;<br>import java.io.Serializable;</p>
<p>/**</p>
<ul>
<li>Hashtable is a synchronized implementation of {@link Map}. All optional operations are supported.<br>*</li>
<li><p>Neither keys nor values can be null. (Use {@code HashMap} or {@code LinkedHashMap} if you</p></li>
<li>need null keys or values.)<br>*</li>
<li>@param <k> the type of keys maintained by this map</k></li>
<li>@param <v> the type of mapped values</v></li>
<li><p>@see HashMap<br>*/<br>public class Hashtable<k, v=""> extends Dictionary<k, v=""></k,></k,></p>
<pre><code><span class="literal">implements</span> <span class="built_in">Map</span>&lt;K, V&gt;, Cloneable, Serializable {
</code></pre><p> /**</p>
<ul>
<li>Min capacity (other than zero) for a Hashtable. Must be a power of two</li>
<li><p>greater than 1 (and less than 1 &lt;&lt; 30).<br>*/<br>private static final int MINIMUM_CAPACITY = 4;</p>
<p>/**</p>
</li>
<li><p>Max capacity for a Hashtable. Must be a power of two &gt;= MINIMUM_CAPACITY.<br>*/<br>private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</p>
<p>/**</p>
</li>
<li>An empty table shared by all zero-capacity maps (typically from default</li>
<li>constructor). It is never written to, and replaced on first put. Its size</li>
<li>is set to half the minimum, so that the first resize will create a</li>
<li><p>minimum-sized table.<br>*/<br>private static final Entry[] EMPTY_TABLE</p>
<pre><code><span class="header">= new HashtableEntry[MINIMUM_CAPACITY &gt;&gt;&gt; 1];</span>
</code></pre><p>/**</p>
</li>
<li>The default load factor. Note that this implementation ignores the</li>
<li>load factor, but cannot do away with it entirely because it’s</li>
<li>mentioned in the API.<br>*</li>
<li><p>Note that this constant has no impact on the behavior of the program,</p></li>
<li>but it is emitted as part of the serialized form. The load factor of</li>
<li>.75 is hardwired into the program, which uses cheap shifts in place of</li>
<li><p>expensive division.<br>*/<br>private static final float DEFAULT_LOAD_FACTOR = .75F;</p>
<p>/**</p>
</li>
<li><p>The hash table.<br>*/<br>private transient HashtableEntry<k, v="">[] table;</k,></p>
<p>/**</p>
</li>
<li><p>The number of mappings in this hash map.<br>*/<br>private transient int size;</p>
<p>/**</p>
</li>
<li>Incremented by “structural modifications” to allow (best effort)</li>
<li><p>detection of concurrent modification.<br>*/<br>private transient int modCount;</p>
<p>/**</p>
</li>
<li>The table is rehashed when its size exceeds this threshold.</li>
<li>The value of this field is generally .75 * capacity, except when</li>
<li>the capacity is zero, as described in the EMPTY_TABLE declaration</li>
<li><p>above.<br>*/<br>private transient int threshold;</p>
<p>// Views - lazily initialized<br>private transient Set<k> keySet;<br>private transient Set<entry<k, v="">&gt; entrySet;<br>private transient Collection<v> values;</v></entry<k,></k></p>
<p>/**</p>
</li>
<li>Constructs a new {@code Hashtable} using the default capacity and load</li>
<li><p>factor.<br>*/<br>@SuppressWarnings(“unchecked”)<br>public Hashtable() {<br> table = (HashtableEntry<k, v="">[]) EMPTY_TABLE;<br> threshold = -1; // Forces first put invocation to replace EMPTY_TABLE<br>}</k,></p>
<p>/**</p>
</li>
<li>Constructs a new {@code Hashtable} using the specified capacity and the</li>
<li>default load factor.<br>*</li>
<li>@param capacity</li>
<li><p>the initial capacity.<br>*/<br>public Hashtable(int capacity) {<br>if (capacity &lt; 0) {<br>throw new IllegalArgumentException(“Capacity: “ + capacity);<br>}</p>
<p>if (capacity == 0) {<br>@SuppressWarnings(“unchecked”)<br>HashtableEntry<k, v="">[] tab = (HashtableEntry<k, v="">[]) EMPTY_TABLE;<br>table = tab;<br>threshold = -1; // Forces first put() to replace EMPTY_TABLE<br>return;<br>}</k,></k,></p>
<p>if (capacity &lt; MINIMUM_CAPACITY) {<br>capacity = MINIMUM_CAPACITY;<br>} else if (capacity &gt; MAXIMUM_CAPACITY) {<br>capacity = MAXIMUM_CAPACITY;<br>} else {<br>capacity = Collections.roundUpToPowerOfTwo(capacity);<br>}<br>makeTable(capacity);<br>}</p>
<p>/**</p>
</li>
<li>Constructs a new {@code Hashtable} using the specified capacity and load</li>
<li>factor.<br>*</li>
<li>@param capacity</li>
<li>the initial capacity.</li>
<li>@param loadFactor</li>
<li><p>the initial load factor.<br>*/<br>public Hashtable(int capacity, float loadFactor) {<br>this(capacity);</p>
<p>if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) {<br>throw new IllegalArgumentException(“Load factor: “ + loadFactor);<br>}</p>
<p>/*</p>
<ul>
<li>Note that this implementation ignores loadFactor; it always uses</li>
<li>a load factor of 3/4. This simplifies the code and generally</li>
<li>improves performance.<br>*/<br>}</li>
</ul>
<p>/**</p>
</li>
<li>Constructs a new instance of {@code Hashtable} containing the mappings</li>
<li>from the specified map.<br>*</li>
<li>@param map</li>
<li><p>the mappings to add.<br>*/<br>public Hashtable(Map&lt;? extends K, ? extends V&gt; map) {<br>this(capacityForInitSize(map.size()));<br>constructorPutAll(map);<br>}</p>
<p>/**</p>
</li>
<li>Inserts all of the elements of map into this Hashtable in a manner</li>
<li>suitable for use by constructors and pseudo-constructors (i.e., clone,</li>
<li><p>readObject).<br>*/<br>private void constructorPutAll(Map&lt;? extends K, ? extends V&gt; map) {<br> if (table == EMPTY_TABLE) {</p>
<pre><code>doubleCapacity<span class="comment">()</span>; <span class="comment">// Don't do unchecked puts to a shared table.</span>
</code></pre><p> }<br> for (Entry&lt;? extends K, ? extends V&gt; e : map.entrySet()) {</p>
<pre><code>constructorPut<span class="list">(<span class="keyword">e</span>.getKey<span class="list">()</span>, e.getValue<span class="list">()</span>)</span><span class="comment">;</span>
</code></pre><p> }<br>}</p>
<p>/**</p>
</li>
<li>Returns an appropriate capacity for the specified initial size. Does</li>
<li>not round the result up to a power of two; the caller must do this!</li>
<li><p>The returned value will be between 0 and MAXIMUM_CAPACITY (inclusive).<br>*/<br>private static int capacityForInitSize(int size) {<br> int result = (size &gt;&gt; 1) + size; // Multiply by 3/2 to allow for growth</p>
<p> // boolean expr is equivalent to result &gt;= 0 &amp;&amp; result&lt;MAXIMUM_CAPACITY<br> return (result &amp; ~(MAXIMUM_CAPACITY-1))==0 ? result : MAXIMUM_CAPACITY;<br>}</p>
<p>/**</p>
</li>
<li>Returns a new {@code Hashtable} with the same key/value pairs, capacity</li>
<li>and load factor.<br>*</li>
<li>@return a shallow copy of this {@code Hashtable}.</li>
<li><p>@see java.lang.Cloneable<br><em>/<br>@SuppressWarnings(“unchecked”)<br>@Override public synchronized Object clone() {<br> /</em></p>
<ul>
<li>This could be made more efficient. It unnecessarily hashes all of</li>
<li><p>the elements in the map.<br>*/<br>Hashtable<k, v=""> result;<br>try {<br> result = (Hashtable<k, v="">) super.clone();<br>} catch (CloneNotSupportedException e) {<br> throw new AssertionError(e);<br>}</k,></k,></p>
<p>// Restore clone to empty state, retaining our capacity and threshold<br>result.makeTable(table.length);<br>result.size = 0;<br>result.keySet = null;<br>result.entrySet = null;<br>result.values = null;</p>
<p>result.constructorPutAll(this);<br>return result;<br>}</p>
</li>
</ul>
<p>/**</p>
</li>
<li>Returns true if this {@code Hashtable} has no key/value pairs.<br>*</li>
<li>@return {@code true} if this {@code Hashtable} has no key/value pairs,</li>
<li>{@code false} otherwise.</li>
<li><p>@see #size<br>*/<br>public synchronized boolean isEmpty() {<br> return size == 0;<br>}</p>
<p>/**</p>
</li>
<li>Returns the number of key/value pairs in this {@code Hashtable}.<br>*</li>
<li>@return the number of key/value pairs in this {@code Hashtable}.</li>
<li>@see #elements</li>
<li><p>@see #keys<br>*/<br>public synchronized int size() {<br> return size;<br>}</p>
<p>/**</p>
</li>
<li>Returns the value associated with the specified key in this</li>
<li>{@code Hashtable}.<br>*</li>
<li>@param key</li>
<li>the key of the value returned.</li>
<li>@return the value associated with the specified key, or {@code null} if</li>
<li>the specified key does not exist.</li>
<li><p>@see #put<br>*/<br>public synchronized V get(Object key) {<br> int hash = Collections.secondaryHash(key);<br> HashtableEntry<k, v="">[] tab = table;<br> for (HashtableEntry<k, v=""> e = tab[hash &amp; (tab.length - 1)];</k,></k,></p>
<pre><code>    <span class="literal">e</span> != null; <span class="literal">e</span> = <span class="literal">e</span>.next) {
K eKey = <span class="literal">e</span>.key;
<span class="keyword">if</span> (eKey == key || (<span class="literal">e</span>.hash == hash &amp;&amp; key.equals(eKey))) {
    <span class="keyword">return</span> <span class="literal">e</span>.value;
}
</code></pre><p> }<br> return null;<br>}</p>
<p>/**</p>
</li>
<li>Returns true if this {@code Hashtable} contains the specified object as a</li>
<li>key of one of the key/value pairs.<br>*</li>
<li>@param key</li>
<li>the object to look for as a key in this {@code Hashtable}.</li>
<li>@return {@code true} if object is a key in this {@code Hashtable},</li>
<li>{@code false} otherwise.</li>
<li>@see #contains</li>
<li><p>@see java.lang.Object#equals<br>*/<br>public synchronized boolean containsKey(Object key) {<br> int hash = Collections.secondaryHash(key);<br> HashtableEntry<k, v="">[] tab = table;<br> for (HashtableEntry<k, v=""> e = tab[hash &amp; (tab.length - 1)];</k,></k,></p>
<pre><code>    <span class="literal">e</span> != null; <span class="literal">e</span> = <span class="literal">e</span>.next) {
K eKey = <span class="literal">e</span>.key;
<span class="keyword">if</span> (eKey == key || (<span class="literal">e</span>.hash == hash &amp;&amp; key.equals(eKey))) {
    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><p> }<br> return false;<br>}</p>
<p>/**</p>
</li>
<li>Searches this {@code Hashtable} for the specified value.<br>*</li>
<li>@param value</li>
<li>the object to search for.</li>
<li>@return {@code true} if {@code value} is a value of this</li>
<li><p>{@code Hashtable}, {@code false} otherwise.<br>*/<br>public synchronized boolean containsValue(Object value) {<br>if (value == null) {<br>throw new NullPointerException(“value == null”);<br>}</p>
<p>HashtableEntry[] tab = table;<br>int len = tab.length;</p>
<p>for (int i = 0; i &lt; len; i++) {<br>for (HashtableEntry e = tab[i]; e != null; e = e.next) {<br> if (value.equals(e.value)) {</p>
<pre><code><span class="keyword">return</span> <span class="literal">true</span>;
</code></pre><p> }<br>}<br>}<br>return false;<br>}</p>
<p>/**</p>
</li>
<li>Returns true if this {@code Hashtable} contains the specified object as</li>
<li>the value of at least one of the key/value pairs.<br>*</li>
<li>@param value</li>
<li>the object to look for as a value in this {@code Hashtable}.</li>
<li>@return {@code true} if object is a value in this {@code Hashtable},</li>
<li>{@code false} otherwise.</li>
<li>@see #containsKey</li>
<li><p>@see java.lang.Object#equals<br>*/<br>public boolean contains(Object value) {<br> return containsValue(value);<br>}</p>
<p>/**</p>
</li>
<li>Associate the specified value with the specified key in this</li>
<li>{@code Hashtable}. If the key already exists, the old value is replaced.</li>
<li>The key and value cannot be null.<br>*</li>
<li>@param key</li>
<li>the key to add.</li>
<li>@param value</li>
<li>the value to add.</li>
<li>@return the old value associated with the specified key, or {@code null}</li>
<li>if the key did not exist.</li>
<li>@see #elements</li>
<li>@see #get</li>
<li>@see #keys</li>
<li><p>@see java.lang.Object#equals<br>*/<br>public synchronized V put(K key, V value) {<br> if (key == null) {</p>
<pre><code><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);
</code></pre><p> } else if (value == null) {</p>
<pre><code><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"value == null"</span>);
</code></pre><p> }<br> int hash = Collections.secondaryHash(key);<br> HashtableEntry<k, v="">[] tab = table;<br> int index = hash &amp; (tab.length - 1);<br> HashtableEntry<k, v=""> first = tab[index];<br> for (HashtableEntry<k, v=""> e = first; e != null; e = e.next) {</k,></k,></k,></p>
<pre><code><span class="keyword">if</span> (<span class="literal">e</span>.hash == hash &amp;&amp; key.equals(<span class="literal">e</span>.key)) {
    V oldValue = <span class="literal">e</span>.value;
    <span class="literal">e</span>.value = value;
    <span class="keyword">return</span> oldValue;
}
</code></pre><p> }</p>
<p> // No entry for key is present; create one<br> modCount++;<br> if (size++ &gt; threshold) {</p>
<pre><code>rehash();  // Does nothing!!
<span class="keyword">tab</span> = doubleCapacity();
<span class="built_in">index</span> = hash &amp; (<span class="keyword">tab</span>.length - <span class="number">1</span>);
<span class="keyword">first</span> = <span class="keyword">tab</span>[<span class="built_in">index</span>];
</code></pre><p> }<br> tab[index] = new HashtableEntry<k, v="">(key, value, hash, first);<br> return null;<br>}</k,></p>
<p>/**</p>
</li>
<li>This method is just like put, except that it doesn’t do things that</li>
<li>are inappropriate or unnecessary for constructors and pseudo-constructors</li>
<li>(i.e., clone, readObject). In particular, this method does not check to</li>
<li><p>ensure that capacity is sufficient, and does not increment modCount.<br>*/<br>private void constructorPut(K key, V value) {<br> if (key == null) {</p>
<pre><code><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"key == null"</span>);
</code></pre><p> } else if (value == null) {</p>
<pre><code><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"value == null"</span>);
</code></pre><p> }<br> int hash = Collections.secondaryHash(key);<br> HashtableEntry<k, v="">[] tab = table;<br> int index = hash &amp; (tab.length - 1);<br> HashtableEntry<k, v=""> first = tab[index];<br> for (HashtableEntry<k, v=""> e = first; e != null; e = e.next) {</k,></k,></k,></p>
<pre><code><span class="keyword">if</span> (<span class="literal">e</span>.hash == hash &amp;&amp; key.equals(<span class="literal">e</span>.key)) {
    <span class="literal">e</span>.value = value;
    <span class="keyword">return</span>;
}
</code></pre><p> }</p>
<p> // No entry for key is present; create one<br> tab[index] = new HashtableEntry<k, v="">(key, value, hash, first);<br> size++;<br>}</k,></p>
<p>/**</p>
</li>
<li>Copies every mapping to this {@code Hashtable} from the specified map.<br>*</li>
<li>@param map</li>
<li><p>the map to copy mappings from.<br>*/<br>public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; map) {<br>ensureCapacity(map.size());<br>for (Entry&lt;? extends K, ? extends V&gt; e : map.entrySet()) {<br>put(e.getKey(), e.getValue());<br>}<br>}</p>
<p>/**</p>
</li>
<li>Ensures that the hash table has sufficient capacity to store the</li>
<li>specified number of mappings, with room to grow. If not, it increases the</li>
<li>capacity as appropriate. Like doubleCapacity, this method moves existing</li>
<li>entries to new buckets as appropriate. Unlike doubleCapacity, this method</li>
<li>can grow the table by factors of 2^n for n &gt; 1. Hopefully, a single call</li>
<li>to this method will be faster than multiple calls to doubleCapacity.<br>*</li>
<li><p></p><p>This method is called only by putAll.<br>*/<br>private void ensureCapacity(int numMappings) {<br>int newCapacity = Collections.roundUpToPowerOfTwo(capacityForInitSize(numMappings));<br>HashtableEntry<k, v="">[] oldTable = table;<br>int oldCapacity = oldTable.length;<br>if (newCapacity &lt;= oldCapacity) {</k,></p>
<pre><code><span class="keyword">return</span>;
</code></pre><p>}</p>
<p>rehash();  // Does nothing!!</p>
<p>if (newCapacity == oldCapacity * 2) {</p>
<pre><code>doubleCapacity();
<span class="keyword">return</span>;
</code></pre><p>}</p>
<p>// We’re growing by at least 4x, rehash in the obvious way<br>HashtableEntry<k, v="">[] newTable = makeTable(newCapacity);<br>if (size != 0) {</k,></p>
<pre><code>int newMask = newCapacity - <span class="number">1</span>;
<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; oldCapacity; i++) {
    <span class="keyword">for</span> (HashtableEntry&lt;K, V&gt; <span class="literal">e</span> = oldTable[i]; <span class="literal">e</span> != null;) {
        HashtableEntry&lt;K, V&gt; oldNext = <span class="literal">e</span>.next;
        int newIndex = <span class="literal">e</span>.hash &amp; newMask;
        HashtableEntry&lt;K, V&gt; newNext = newTable[newIndex];
        newTable[newIndex] = <span class="literal">e</span>;
        <span class="literal">e</span>.next = newNext;
        <span class="literal">e</span> = oldNext;
    }
}
</code></pre><p>}<br>}</p>
<p>/**</p>
</li>
<li>Increases the capacity of this {@code Hashtable}. This method is called</li>
<li><p>when the size of this {@code Hashtable} exceeds the load factor.<br><em>/<br>protected void rehash() {<br> /</em></p>
<ul>
<li>This method has no testable semantics, other than that it gets</li>
<li>called from time to time.<br>*/<br>}</li>
</ul>
<p>/**</p>
</li>
<li>Allocate a table of the given capacity and set the threshold accordingly.</li>
<li><p>@param newCapacity must be a power of two<br>*/<br>private HashtableEntry<k, v="">[] makeTable(int newCapacity) {<br> @SuppressWarnings(“unchecked”) HashtableEntry<k, v="">[] newTable</k,></k,></p>
<pre><code><span class="header">= (HashtableEntry&lt;K, V&gt;[]) new HashtableEntry[newCapacity];</span>
</code></pre><p> table = newTable;<br> threshold = (newCapacity &gt;&gt; 1) + (newCapacity &gt;&gt; 2); // 3/4 capacity<br> return newTable;<br>}</p>
<p>/**</p>
</li>
<li>Doubles the capacity of the hash table. Existing entries are placed in</li>
<li>the correct bucket on the enlarged table. If the current capacity is,</li>
<li>MAXIMUM_CAPACITY, this method is a no-op. Returns the table, which</li>
<li><p>will be new unless we were already at MAXIMUM_CAPACITY.<br>*/<br>private HashtableEntry<k, v="">[] doubleCapacity() {<br> HashtableEntry<k, v="">[] oldTable = table;<br> int oldCapacity = oldTable.length;<br> if (oldCapacity == MAXIMUM_CAPACITY) {</k,></k,></p>
<pre><code><span class="keyword">return</span> oldTable;
</code></pre><p> }<br> int newCapacity = oldCapacity * 2;<br> HashtableEntry<k, v="">[] newTable = makeTable(newCapacity);<br> if (size == 0) {</k,></p>
<pre><code><span class="keyword">return</span> newTable;
</code></pre><p> }</p>
<p> for (int j = 0; j &lt; oldCapacity; j++) {</p>
<pre><code><span class="comment">/*
 * Rehash the bucket using the minimum number of field writes.
 * This is the most subtle and delicate code in the class.
 */</span>
HashtableEntry&lt;K, V&gt; <span class="variable">e =</span> oldTable[j];
<span class="keyword">if</span> (<span class="variable">e =</span>= <span class="constant">null</span>) {
    continue;
}
int <span class="variable">highBit =</span> e.hash &amp; oldCapacity;
HashtableEntry&lt;K, V&gt; <span class="variable">broken =</span> <span class="constant">null</span>;
newTable[j | highBit] = e;
for (HashtableEntry&lt;K,V&gt; <span class="variable">n =</span> e.next; n != <span class="constant">null</span>; <span class="variable">e =</span> n, <span class="variable">n =</span> n.next) {
    int <span class="variable">nextHighBit =</span> n.hash &amp; oldCapacity;
    <span class="keyword">if</span> (nextHighBit != highBit) {
        <span class="keyword">if</span> (<span class="variable">broken =</span>= <span class="constant">null</span>)
            newTable[j | nextHighBit] = n;
        <span class="keyword">else</span>
            broken.<span class="variable">next =</span> n;
        <span class="variable">broken =</span> e;
        <span class="variable">highBit =</span> nextHighBit;
    }
}
<span class="keyword">if</span> (broken != <span class="constant">null</span>)
    broken.<span class="variable">next =</span> <span class="constant">null</span>;
</code></pre><p> }<br> return newTable;<br>}</p>
<p>/**</p>
</li>
<li>Removes the key/value pair with the specified key from this</li>
<li>{@code Hashtable}.<br>*</li>
<li>@param key</li>
<li>the key to remove.</li>
<li>@return the value associated with the specified key, or {@code null} if</li>
<li>the specified key did not exist.</li>
<li>@see #get</li>
<li><p>@see #put<br>*/<br>public synchronized V remove(Object key) {<br> int hash = Collections.secondaryHash(key);<br> HashtableEntry<k, v="">[] tab = table;<br> int index = hash &amp; (tab.length - 1);<br> for (HashtableEntry<k, v=""> e = tab[index], prev = null;</k,></k,></p>
<pre><code>    <span class="keyword">e</span> != null; prev = <span class="keyword">e</span>, <span class="keyword">e</span> = <span class="keyword">e</span>.next) {
<span class="keyword">if</span> (<span class="keyword">e</span>.hash == hash &amp;&amp; key.equals(<span class="keyword">e</span>.key)) {
    <span class="keyword">if</span> (prev == null) {
        <span class="keyword">tab</span>[index] = <span class="keyword">e</span>.next;
    } <span class="keyword">else</span> {
        prev.next = <span class="keyword">e</span>.next;
    }
    modCount++;
    size--;
    <span class="keyword">return</span> <span class="keyword">e</span>.value;
}
</code></pre><p> }<br> return null;<br>}</p>
<p>/**</p>
</li>
<li>Removes all key/value pairs from this {@code Hashtable}, leaving the</li>
<li>size zero and the capacity unchanged.<br>*</li>
<li>@see #isEmpty</li>
<li><p>@see #size<br>*/<br>public synchronized void clear() {<br> if (size != 0) {</p>
<pre><code>Arrays.<span class="built_in">fill</span>(table, <span class="keyword">null</span>);
modCount++;
<span class="built_in">size</span> = <span class="number">0</span>;
</code></pre><p> }<br>}</p>
<p>/**</p>
</li>
<li>Returns a set of the keys contained in this {@code Hashtable}. The set</li>
<li>is backed by this {@code Hashtable} so changes to one are reflected by</li>
<li>the other. The set does not support adding.<br>*</li>
<li><p>@return a set of the keys.<br>*/<br>public synchronized Set<k> keySet() {<br> Set<k> ks = keySet;<br> return (ks != null) ? ks : (keySet = new KeySet());<br>}</k></k></p>
<p>/**</p>
</li>
<li>Returns a collection of the values contained in this {@code Hashtable}.</li>
<li>The collection is backed by this {@code Hashtable} so changes to one are</li>
<li>reflected by the other. The collection does not support adding.<br>*</li>
<li><p>@return a collection of the values.<br>*/<br>public synchronized Collection<v> values() {<br> Collection<v> vs = values;<br> return (vs != null) ? vs : (values = new Values());<br>}</v></v></p>
<p>/**</p>
</li>
<li>Returns a set of the mappings contained in this {@code Hashtable}. Each</li>
<li>element in the set is a {@link Map.Entry}. The set is backed by this</li>
<li>{@code Hashtable} so changes to one are reflected by the other. The set</li>
<li>does not support adding.<br>*</li>
<li>@return a set of the mappings.<br>*/<br>public synchronized Set<entry<k, v="">&gt; entrySet() {<br> Set<entry<k, v="">&gt; es = entrySet;<br> return (es != null) ? es : (entrySet = new EntrySet());<br>}</entry<k,></entry<k,></li>
</ul>
</li>
</ul>
<pre><code><span class="javadoc">/**
 * Returns an enumeration on the keys of this {@code Hashtable} instance.
 * The results of the enumeration may be affected if the contents of this
 * {@code Hashtable} are modified.
 *
 *<span class="javadoctag"> @return</span> an enumeration of the keys of this {@code Hashtable}.
 *<span class="javadoctag"> @see</span> #elements
 *<span class="javadoctag"> @see</span> #size
 *<span class="javadoctag"> @see</span> Enumeration
 */</span>
<span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;K&gt; keys() {
    <span class="keyword">return</span> <span class="keyword">new</span> KeyEnumeration();
}

<span class="javadoc">/**
 * Returns an enumeration on the values of this {@code Hashtable}. The
 * results of the Enumeration may be affected if the contents of this
 * {@code Hashtable} are modified.
 *
 *<span class="javadoctag"> @return</span> an enumeration of the values of this {@code Hashtable}.
 *<span class="javadoctag"> @see</span> #keys
 *<span class="javadoctag"> @see</span> #size
 *<span class="javadoctag"> @see</span> Enumeration
 */</span>
<span class="keyword">public</span> <span class="keyword">synchronized</span> Enumeration&lt;V&gt; elements() {
    <span class="keyword">return</span> <span class="keyword">new</span> ValueEnumeration();
}

<span class="javadoc">/**
 * Note: technically the methods of this class should synchronize the
 * backing map.  However, this would require them to have a reference
 * to it, which would cause considerable bloat.  Moreover, the RI
 * behaves the same way.
 */</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HashtableEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{
    <span class="keyword">final</span> K key;
    V value;
    <span class="keyword">final</span> <span class="keyword">int</span> hash;
    HashtableEntry&lt;K, V&gt; next;

    HashtableEntry(K key, V value, <span class="keyword">int</span> hash, HashtableEntry&lt;K, V&gt; next) {
        <span class="keyword">this</span>.key = key;
        <span class="keyword">this</span>.value = value;
        <span class="keyword">this</span>.hash = hash;
        <span class="keyword">this</span>.next = next;
    }

    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function">K <span class="title">getKey</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> key;
    }

    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function">V <span class="title">getValue</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> value;
    }

    <span class="keyword">public</span> <span class="keyword">final</span> <span class="function">V <span class="title">setValue</span><span class="params">(V value)</span> </span>{
        <span class="keyword">if</span> (value == <span class="keyword">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"value == null"</span>);
        }
        V oldValue = <span class="keyword">this</span>.value;
        <span class="keyword">this</span>.value = value;
        <span class="keyword">return</span> oldValue;
    }

    <span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>{
        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Entry)) {
            <span class="keyword">return</span> <span class="keyword">false</span>;
        }
        Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) o;
        <span class="keyword">return</span> key.equals(e.getKey()) &amp;&amp; value.equals(e.getValue());
    }

    <span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">final</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> key.hashCode() ^ value.hashCode();
    }

    <span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">final</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> key + <span class="string">"="</span> + value;
    }
}

<span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>{
    <span class="keyword">int</span> nextIndex;
    HashtableEntry&lt;K, V&gt; nextEntry;
    HashtableEntry&lt;K, V&gt; lastEntryReturned;
    <span class="keyword">int</span> expectedModCount = modCount;

    HashIterator() {
        HashtableEntry&lt;K, V&gt;[] tab = table;
        HashtableEntry&lt;K, V&gt; next = <span class="keyword">null</span>;
        <span class="keyword">while</span> (next == <span class="keyword">null</span> &amp;&amp; nextIndex &lt; tab.length) {
            next = tab[nextIndex++];
        }
        nextEntry = next;
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> nextEntry != <span class="keyword">null</span>;
    }

    HashtableEntry&lt;K, V&gt; nextEntry() {
        <span class="keyword">if</span> (modCount != expectedModCount)
            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();
        <span class="keyword">if</span> (nextEntry == <span class="keyword">null</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();

        HashtableEntry&lt;K, V&gt; entryToReturn = nextEntry;
        HashtableEntry&lt;K, V&gt;[] tab = table;
        HashtableEntry&lt;K, V&gt; next = entryToReturn.next;
        <span class="keyword">while</span> (next == <span class="keyword">null</span> &amp;&amp; nextIndex &lt; tab.length) {
            next = tab[nextIndex++];
        }
        nextEntry = next;
        <span class="keyword">return</span> lastEntryReturned = entryToReturn;
    }

    HashtableEntry&lt;K, V&gt; nextEntryNotFailFast() {
        <span class="keyword">if</span> (nextEntry == <span class="keyword">null</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();

        HashtableEntry&lt;K, V&gt; entryToReturn = nextEntry;
        HashtableEntry&lt;K, V&gt;[] tab = table;
        HashtableEntry&lt;K, V&gt; next = entryToReturn.next;
        <span class="keyword">while</span> (next == <span class="keyword">null</span> &amp;&amp; nextIndex &lt; tab.length) {
            next = tab[nextIndex++];
        }
        nextEntry = next;
        <span class="keyword">return</span> lastEntryReturned = entryToReturn;
    }

    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>{
        <span class="keyword">if</span> (lastEntryReturned == <span class="keyword">null</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();
        <span class="keyword">if</span> (modCount != expectedModCount)
            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();
        Hashtable.<span class="keyword">this</span>.remove(lastEntryReturned.key);
        lastEntryReturned = <span class="keyword">null</span>;
        expectedModCount = modCount;
    }
}

<span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>
        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>{
    <span class="keyword">public</span> <span class="function">K <span class="title">next</span><span class="params">()</span> </span>{ <span class="keyword">return</span> nextEntry().key; }
}

<span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>
        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>{
    <span class="keyword">public</span> <span class="function">V <span class="title">next</span><span class="params">()</span> </span>{ <span class="keyword">return</span> nextEntry().value; }
}

<span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>
        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;&gt; </span>{
    <span class="keyword">public</span> Entry&lt;K, V&gt; next() { <span class="function"><span class="keyword">return</span> <span class="title">nextEntry</span><span class="params">()</span></span>; }
}

<span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyEnumeration</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>
        <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">K</span>&gt; </span>{
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>{ <span class="function"><span class="keyword">return</span> <span class="title">hasNext</span><span class="params">()</span></span>; }
    <span class="keyword">public</span> <span class="function">K <span class="title">nextElement</span><span class="params">()</span> </span>{ <span class="keyword">return</span> nextEntryNotFailFast().key; }
}

<span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueEnumeration</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>
        <span class="keyword">implements</span> <span class="title">Enumeration</span>&lt;<span class="title">V</span>&gt; </span>{
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>{ <span class="function"><span class="keyword">return</span> <span class="title">hasNext</span><span class="params">()</span></span>; }
    <span class="keyword">public</span> <span class="function">V <span class="title">nextElement</span><span class="params">()</span> </span>{ <span class="keyword">return</span> nextEntryNotFailFast().value; }
}

<span class="javadoc">/**
 * Returns true if this map contains the specified mapping.
 */</span>
<span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">boolean</span> <span class="title">containsMapping</span><span class="params">(Object key, Object value)</span> </span>{
    <span class="keyword">int</span> hash = Collections.secondaryHash(key);
    HashtableEntry&lt;K, V&gt;[] tab = table;
    <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);
    <span class="keyword">for</span> (HashtableEntry&lt;K, V&gt; e = tab[index]; e != <span class="keyword">null</span>; e = e.next) {
        <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) {
            <span class="keyword">return</span> e.value.equals(value);
        }
    }
    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// No entry for key</span>
}

<span class="javadoc">/**
 * Removes the mapping from key to value and returns true if this mapping
 * exists; otherwise, returns does nothing and returns false.
 */</span>
<span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">boolean</span> <span class="title">removeMapping</span><span class="params">(Object key, Object value)</span> </span>{
    <span class="keyword">int</span> hash = Collections.secondaryHash(key);
    HashtableEntry&lt;K, V&gt;[] tab = table;
    <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);
    <span class="keyword">for</span> (HashtableEntry&lt;K, V&gt; e = tab[index], prev = <span class="keyword">null</span>;
            e != <span class="keyword">null</span>; prev = e, e = e.next) {
        <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) {
            <span class="keyword">if</span> (!e.value.equals(value)) {
                <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// Map has wrong value for key</span>
            }
            <span class="keyword">if</span> (prev == <span class="keyword">null</span>) {
                tab[index] = e.next;
            } <span class="keyword">else</span> {
                prev.next = e.next;
            }
            modCount++;
            size--;
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
    }
    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// No entry for key</span>
}

<span class="javadoc">/**
 * Compares this {@code Hashtable} with the specified object and indicates
 * if they are equal. In order to be equal, {@code object} must be an
 * instance of Map and contain the same key/value pairs.
 *
 *<span class="javadoctag"> @param</span> object
 *            the object to compare with this object.
 *<span class="javadoctag"> @return</span> {@code true} if the specified object is equal to this Map,
 *         {@code false} otherwise.
 *<span class="javadoctag"> @see</span> #hashCode
 */</span>
<span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>{
    <span class="keyword">return</span> (object <span class="keyword">instanceof</span> Map) &amp;&amp;
            entrySet().equals(((Map&lt;?, ?&gt;)object).entrySet());
}

<span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{
    <span class="keyword">int</span> result = <span class="number">0</span>;
    <span class="keyword">for</span> (Entry&lt;K, V&gt; e : entrySet()) {
        K key = e.getKey();
        V value = e.getValue();
        <span class="keyword">if</span> (key == <span class="keyword">this</span> || value == <span class="keyword">this</span>) {
            <span class="keyword">continue</span>;
        }
        result += (key != <span class="keyword">null</span> ? key.hashCode() : 0)
                ^ (value != <span class="keyword">null</span> ? value.hashCode() : 0);
    }
    <span class="keyword">return</span> result;
}

<span class="javadoc">/**
 * A rough estimate of the number of characters per entry, for use
 * when creating a string buffer in the toString method.
 */</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CHARS_PER_ENTRY = <span class="number">15</span>;

<span class="javadoc">/**
 * Returns the string representation of this {@code Hashtable}.
 *
 *<span class="javadoctag"> @return</span> the string representation of this {@code Hashtable}.
 */</span>
<span class="annotation">@Override</span> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>{
    StringBuilder result = <span class="keyword">new</span> StringBuilder(CHARS_PER_ENTRY * size);
    result.append(<span class="string">'{'</span>);
    Iterator&lt;Entry&lt;K, V&gt;&gt; i = entrySet().iterator();
    <span class="keyword">boolean</span> hasMore = i.hasNext();
    <span class="keyword">while</span> (hasMore) {
        Entry&lt;K, V&gt; entry = i.next();

        K key = entry.getKey();
        result.append(key == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : key.toString());

        result.append(<span class="string">'='</span>);

        V value = entry.getValue();
        result.append(value == <span class="keyword">this</span> ? <span class="string">"(this Map)"</span> : value.toString());

        <span class="keyword">if</span> (hasMore = i.hasNext()) {
            result.append(<span class="string">", "</span>);
        }
    }

    result.append(<span class="string">'}'</span>);
    <span class="function"><span class="keyword">return</span> result.<span class="title">toString</span><span class="params">()</span></span>;
}

<span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>{
    <span class="keyword">public</span> Iterator&lt;K&gt; iterator() {
        <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> Hashtable.<span class="keyword">this</span>.size();
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>{
        <span class="function"><span class="keyword">return</span> <span class="title">containsKey</span><span class="params">(o)</span></span>;
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="keyword">int</span> oldSize = size;
            Hashtable.<span class="keyword">this</span>.remove(o);
            <span class="keyword">return</span> size != oldSize;
        }
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{
        Hashtable.<span class="keyword">this</span>.clear();
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">removeAll</span><span class="params">(collection)</span></span>;
        }
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">retainAll</span><span class="params">(collection)</span></span>;
        }
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">containsAll</span><span class="params">(collection)</span></span>;
        }
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">equals</span><span class="params">(object)</span></span>;
        }
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">hashCode</span><span class="params">()</span></span>;
        }
    }
    <span class="keyword">public</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">toString</span><span class="params">()</span></span>;
        }
    }
    <span class="keyword">public</span> Object[] toArray() {
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">toArray</span><span class="params">()</span></span>;
        }
    }
    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) {
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">toArray</span><span class="params">(a)</span></span>;
        }
    }
}

<span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>{
    <span class="keyword">public</span> Iterator&lt;V&gt; iterator() {
        <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator();
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> Hashtable.<span class="keyword">this</span>.size();
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>{
        <span class="function"><span class="keyword">return</span> <span class="title">containsValue</span><span class="params">(o)</span></span>;
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{
        Hashtable.<span class="keyword">this</span>.clear();
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">containsAll</span><span class="params">(collection)</span></span>;
        }
    }
    <span class="keyword">public</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">toString</span><span class="params">()</span></span>;
        }
    }
    <span class="keyword">public</span> Object[] toArray() {
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">toArray</span><span class="params">()</span></span>;
        }
    }
    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) {
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">toArray</span><span class="params">(a)</span></span>;
        }
    }
}

<span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;&gt; </span>{
    <span class="keyword">public</span> Iterator&lt;Entry&lt;K, V&gt;&gt; iterator() {
        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>{
        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Entry))
            <span class="keyword">return</span> <span class="keyword">false</span>;
        Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;) o;
        <span class="keyword">return</span> containsMapping(e.getKey(), e.getValue());
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>{
        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Entry))
            <span class="keyword">return</span> <span class="keyword">false</span>;
        Entry&lt;?, ?&gt; e = (Entry&lt;?, ?&gt;)o;
        <span class="keyword">return</span> removeMapping(e.getKey(), e.getValue());
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> Hashtable.<span class="keyword">this</span>.size();
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{
        Hashtable.<span class="keyword">this</span>.clear();
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">removeAll</span><span class="params">(collection)</span></span>;
        }
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">retainAll</span><span class="params">(collection)</span></span>;
        }
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">containsAll</span><span class="params">(collection)</span></span>;
        }
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">equals</span><span class="params">(object)</span></span>;
        }
    }
    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> Hashtable.<span class="keyword">this</span>.hashCode();
    }
    <span class="keyword">public</span> <span class="function">String <span class="title">toString</span><span class="params">()</span> </span>{
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">toString</span><span class="params">()</span></span>;
        }
    }
    <span class="keyword">public</span> Object[] toArray() {
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">toArray</span><span class="params">()</span></span>;
        }
    }
    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) {
        <span class="keyword">synchronized</span> (Hashtable.<span class="keyword">this</span>) {
            <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">toArray</span><span class="params">(a)</span></span>;
        }
    }
}

<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1421746759512286392</span>L;

<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = {
    <span class="keyword">new</span> ObjectStreamField(<span class="string">"threshold"</span>, <span class="keyword">int</span>.class),
    <span class="keyword">new</span> ObjectStreamField(<span class="string">"loadFactor"</span>, <span class="keyword">float</span>.class),
};

<span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span>
        <span class="keyword">throws</span> IOException </span>{
    <span class="comment">// Emulate loadFactor field for other implementations to read</span>
    ObjectOutputStream.PutField fields = stream.putFields();
    fields.put(<span class="string">"threshold"</span>,  (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * table.length));
    fields.put(<span class="string">"loadFactor"</span>, DEFAULT_LOAD_FACTOR);
    stream.writeFields();

    stream.writeInt(table.length); <span class="comment">// Capacity</span>
    stream.writeInt(size);
    <span class="keyword">for</span> (Entry&lt;K, V&gt; e : entrySet()) {
        stream.writeObject(e.getKey());
        stream.writeObject(e.getValue());
    }
}

<span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException,
        ClassNotFoundException </span>{
    stream.defaultReadObject();
    <span class="keyword">int</span> capacity = stream.readInt();
    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Capacity: "</span> + capacity);
    }
    <span class="keyword">if</span> (capacity &lt; MINIMUM_CAPACITY) {
        capacity = MINIMUM_CAPACITY;
    } <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(capacity &gt; MAXIMUM_CAPACITY)</span> </span>{
        capacity = MAXIMUM_CAPACITY;
    } <span class="keyword">else</span> {
        capacity = Collections.roundUpToPowerOfTwo(capacity);
    }
    makeTable(capacity);

    <span class="keyword">int</span> size = stream.readInt();
    <span class="keyword">if</span> (size &lt; <span class="number">0</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Size: "</span> + size);
    }

    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {
        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) K key = (K) stream.readObject();
        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) V val = (V) stream.readObject();
        constructorPut(key, val);
    }
}
</code></pre><p>}<br>``` </p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/源码学习/">源码学习</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/源码学习/">源码学习</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://chenfuduo.me/2015/06/10/Hashtable源码学习/" data-title="Hashtable源码学习 | louis.chen" data-tsina="2338582935" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/06/15/IntentService和Service/" title="IntentService和Service">
  <strong>上一篇：</strong><br/>
  <span>
  IntentService和Service</span>
</a>
</div>


<div class="next">
<a href="/2015/06/09/HashMap源码学习/"  title="HashMap源码学习">
 <strong>下一篇：</strong><br/> 
 <span>HashMap源码学习
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/06/10/Hashtable源码学习/" data-title="Hashtable源码学习" data-url="http://chenfuduo.me/2015/06/10/Hashtable源码学习/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#开头的注释"><span class="toc-number">1.</span> <span class="toc-text">开头的注释</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总体"><span class="toc-number">2.</span> <span class="toc-text">总体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#容量机制"><span class="toc-number">3.</span> <span class="toc-text">容量机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#克隆"><span class="toc-number">4.</span> <span class="toc-text">克隆</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#判空和映射的数量"><span class="toc-number">5.</span> <span class="toc-text">判空和映射的数量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#返回指定的key"><span class="toc-number">6.</span> <span class="toc-text">返回指定的key</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#是否包含key和value"><span class="toc-number">7.</span> <span class="toc-text">是否包含key和value</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#确保hash表有足够的容量"><span class="toc-number">8.</span> <span class="toc-text">确保hash表有足够的容量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rehash"><span class="toc-number">9.</span> <span class="toc-text">rehash</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#创建新的hash表"><span class="toc-number">10.</span> <span class="toc-text">创建新的hash表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#移除指定key的映射"><span class="toc-number">11.</span> <span class="toc-text">移除指定key的映射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#返回Key组成的集合"><span class="toc-number">12.</span> <span class="toc-text">返回Key组成的集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#返回当前map中所有value的collection集合"><span class="toc-number">13.</span> <span class="toc-text">返回当前map中所有value的collection集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#返回当前map中所有映射的set"><span class="toc-number">14.</span> <span class="toc-text">返回当前map中所有映射的set</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#elements方法"><span class="toc-number">15.</span> <span class="toc-text">elements方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#链表结点的数据结构"><span class="toc-number">16.</span> <span class="toc-text">链表结点的数据结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#迭代器相关"><span class="toc-number">17.</span> <span class="toc-text">迭代器相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#是否包含映射"><span class="toc-number">18.</span> <span class="toc-text">是否包含映射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#移除映射"><span class="toc-number">19.</span> <span class="toc-text">移除映射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#重写的equals、hashCode()和toString()方法"><span class="toc-number">20.</span> <span class="toc-text">重写的equals、hashCode()和toString()方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#KeySet、Values、EntrySet类"><span class="toc-number">21.</span> <span class="toc-text">KeySet、Values、EntrySet类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#序列化"><span class="toc-number">22.</span> <span class="toc-text">序列化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">23.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码"><span class="toc-number">24.</span> <span class="toc-text">源码</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/JVM/" title="JVM">JVM<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/MFC/" title="MFC">MFC<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/收藏/" title="收藏">收藏<sup>1</sup></a></li>
		  
		
		  
		
		  
			<li><a href="/categories/源码学习/" title="源码学习">源码学习<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/生活/" title="生活">生活<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/移动开发/" title="移动开发">移动开发<sup>31</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>36</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>36</sup></a></li>
			
		
			
				<li><a href="/tags/移动开发/" title="移动开发">移动开发<sup>31</sup></a></li>
			
		
			
				<li><a href="/tags/源码学习/" title="源码学习">源码学习<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/生活/" title="生活">生活<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/JVM/" title="JVM">JVM<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/收藏/" title="收藏">收藏<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Android动画/" title="Android动画">Android动画<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/MFC/" title="MFC">MFC<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.vogella.com/tutorials/android.html" target="_blank" title="Vogella">Vogella</a>
            
          </li>
        
    </ul>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=2338582935&verifier=59b78413&dpc=1"></iframe>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> louis.chen,student of USTC,Focus on mobile develop. <br/>
			It is my amibition to make beautiful apps.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2338582935" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/leerduo" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="louis.chen">louis.chen</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"chenlouis"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F63c029dba1e367df2c8ffa39a309056a' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
