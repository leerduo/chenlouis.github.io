
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Java内存区域与内存溢出异常 | louis.chen</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="louis.chen">
    

    
    <meta name="description" content="JVM部分主要围绕内存动态分配和垃圾收集技术展开；本篇介绍Java虚拟机内存的各个区域，以及这些区域的作用，服务对象以及可能产生的问题。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java内存区域与内存溢出异常">
<meta property="og:url" content="http://chenfuduo.me/2015/05/26/Java内存区域与内存溢出异常/index.html">
<meta property="og:site_name" content="louis.chen">
<meta property="og:description" content="JVM部分主要围绕内存动态分配和垃圾收集技术展开；本篇介绍Java虚拟机内存的各个区域，以及这些区域的作用，服务对象以及可能产生的问题。">
<meta property="og:image" content="http://duoinfo.sinaapp.com/pro/picofoschina/10.jpg">
<meta property="og:image" content="http://duoinfo.sinaapp.com/pro/picofoschina/11.jpg">
<meta property="og:image" content="http://duoinfo.sinaapp.com/pro/picofoschina/12.jpg">
<meta property="og:image" content="http://duoinfo.sinaapp.com/pro/picofoschina/13.PNG">
<meta property="og:image" content="http://duoinfo.sinaapp.com/pro/picofoschina/15.PNG">
<meta property="og:image" content="http://duoinfo.sinaapp.com/pro/picofoschina/14.PNG">
<meta property="og:image" content="http://duoinfo.sinaapp.com/pro/picofoschina/16.PNG">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java内存区域与内存溢出异常">
<meta name="twitter:description" content="JVM部分主要围绕内存动态分配和垃圾收集技术展开；本篇介绍Java虚拟机内存的各个区域，以及这些区域的作用，服务对象以及可能产生的问题。">

    
    <link rel="alternative" href="/atom.xml" title="louis.chen" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="louis.chen" title="louis.chen"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="louis.chen">louis.chen</a></h1>
				<h2 class="blog-motto">纸上得来终觉浅,绝知此事要躬行。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/project">项目</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:chenfuduo.me">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/05/26/Java内存区域与内存溢出异常/" title="Java内存区域与内存溢出异常" itemprop="url">Java内存区域与内存溢出异常</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="louis.chen" target="_blank" itemprop="author">louis.chen</a>
		
  <p class="article-time">
    <time datetime="2015-05-26T00:22:25.000Z" itemprop="datePublished"> 发表于 2015-05-26</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#运行时数据区域"><span class="toc-number">1.</span> <span class="toc-text">运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#程序计数器"><span class="toc-number">1.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java虚拟机栈"><span class="toc-number">1.2.</span> <span class="toc-text">Java虚拟机栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法栈"><span class="toc-number">1.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java堆"><span class="toc-number">1.4.</span> <span class="toc-text">Java堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区"><span class="toc-number">1.5.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时常量池"><span class="toc-number">1.6.</span> <span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直接内存"><span class="toc-number">1.7.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HotSpot虚拟机对象探秘"><span class="toc-number">2.</span> <span class="toc-text">HotSpot虚拟机对象探秘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的创建"><span class="toc-number">2.1.</span> <span class="toc-text">对象的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的内存布局"><span class="toc-number">2.2.</span> <span class="toc-text">对象的内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的访问定位"><span class="toc-number">2.3.</span> <span class="toc-text">对象的访问定位</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OutOfMemoryError异常"><span class="toc-number">3.</span> <span class="toc-text">OutOfMemoryError异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#配置参数"><span class="toc-number">3.1.</span> <span class="toc-text">配置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java堆溢出"><span class="toc-number">3.2.</span> <span class="toc-text">Java堆溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机栈和本地方法栈溢出"><span class="toc-number">3.3.</span> <span class="toc-text">虚拟机栈和本地方法栈溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区和运行时常量池溢出"><span class="toc-number">3.4.</span> <span class="toc-text">方法区和运行时常量池溢出</span></a></li></ol></li></ol>
		
		</div>
		
		<p>JVM部分主要围绕内存动态分配和垃圾收集技术展开；本篇介绍Java虚拟机内存的各个区域，以及这些区域的作用，服务对象以及可能产生的问题。<br><a id="more"></a></p>
<h1 id="运行时数据区域">运行时数据区域</h1><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。<br><img src="http://duoinfo.sinaapp.com/pro/picofoschina/10.jpg" alt="Java虚拟机运行时数据区"></p>
<h2 id="程序计数器">程序计数器</h2><ul>
<li>当前线程所执行的字节码行号指示器</li>
<li>字节码解释器工作依赖计数器控制完成</li>
<li>通过执行线程行号记录，让线程轮流切换各条线程之间计数器互不影响</li>
<li>线程私有，生命周期与线程相同，随JVM启动而生，JVM关闭而死</li>
<li>线程执行Java方法时，记录其正在执行的虚拟机字节码指令地址</li>
<li>线程执行Native方法时，计数器记录为空（Undefined）</li>
<li>唯一在Java虚拟机规范中没有规定任何OutOfMemoryError情况区域<br>程序计数器(Program Counter Register)是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核） 只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响、独立存储，我们称这类内存区域为“线程私有”的内存。<br>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空 （Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。 <h2 id="Java虚拟机栈">Java虚拟机栈</h2></li>
<li>线程私有，生命周期与线程相同</li>
<li>每个方法在执行的同时都会创建一个栈帧用于存储局部变量、操作栈、动态链接、方法出口</li>
<li>每一个方法被调用直至执行完成的过程，就对应着一个栈帧(方法运行时的基础数据结构)在虚拟机栈中从入栈到出栈的过程<br>与程序计数器一样，Java虚拟机栈(Java Vitual Machine Stacks)也是线程私有的，他的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧(Stack Frame)用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br>经常有人把Java内存区分为堆内存和栈内存，这里的”栈”就是现在的虚拟机栈，或者说是虚拟机栈中局部变量表部分。<br>局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(Object reference)和字节码指令地址(returnAddress类型)。<h2 id="本地方法栈">本地方法栈</h2>本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用非常类似，区别在于虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的Native方法服务。  <h2 id="Java堆">Java堆</h2></li>
<li>Java堆（java heap）是Java虚拟机所管理的内存中最大的一块</li>
<li>它是被所有线程共享的一块内存区域，在虚拟机启动时创建<br>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。<br>Java堆是垃圾收集器管理的主要区域。根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的.(通过-Xmx和-Xms控制)<br>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 <h2 id="方法区">方法区</h2>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。<br>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。<h2 id="运行时常量池">运行时常量池</h2>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。<br>Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。<br>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。<br>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。<h2 id="直接内存">直接内存</h2>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。<br>在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。<br>显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。<h1 id="HotSpot虚拟机对象探秘">HotSpot虚拟机对象探秘</h1>本部分探讨HotSpot虚拟机在Java堆中对象分配、布局、和访问的全过程。<h2 id="对象的创建">对象的创建</h2>Java是一门面向对象的编程语言，Java程序运行过程中每时每刻都有对象被创建出来。在语言层面上，创建对象通常（例外：克隆、反序列化）仅仅是一个new关键字而已，而在虚拟机中，对象（本文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？<br>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过的。如果没有，那必须先执行相应的类加载过程。<br>在类加载通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定在下一节对象内存布局时再详细讲解），为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时（说明一下，CMS收集器可以通过UseCMSCompactAtFullCollection或CMSFullGCsBeforeCompaction来整理内存），就通常采用空闲列表。[垃圾收集器下一篇会讲述]<br>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。解决这个问题有两个方案，一种是对分配内存空间的动作进行同步——实际上虚拟机是采用CAS(Content-Addressable Storage:内容寻址存储?)配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲，（TLAB ，Thread Local Allocation Buffer），哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，分配新的TLAB时才需要同步锁定。虚拟机是否使用TLAB，可以通过<code>-XX:+/-UseTLAB</code>参数来设定。<br>内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB的话，这一个工作也可以提前至TLAB分配时进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。<br>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内容，在下一节再详细介绍。<br>在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在Java程序的视角看来，对象创建才刚刚开始——<init>方法还没有执行，所有的字段都为零呢。所以一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。<br>下面代码是HotSpot虚拟机bytecodeInterpreter.cpp中的代码片段（这个解释器实现很少机会实际使用，大部分平台上都使用模板解释器；当代码通过JIT编译器执行时差异就更大了。不过这段代码用于了解HotSpot的运作过程是没有什么问题的）。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确保常量池中存放的是已解释的类 </span></span><br><span class="line"><span class="keyword">if</span> (!constants-&gt;tag_at(index).is_unresolved_klass()) &#123; </span><br><span class="line">    <span class="comment">// 断言确保是klassOop和instanceKlassOop（这部分下一节介绍） </span></span><br><span class="line">    oop entry = (klassOop) *constants-&gt;obj_at_addr(index); </span><br><span class="line">    assert(entry-&gt;is_klass(), <span class="string">"Should be resolved klass"</span>); </span><br><span class="line">    klassOop k_entry = (klassOop) entry; </span><br><span class="line">    assert(k_entry-&gt;klass_part()-&gt;oop_is_instance(), <span class="string">"Should be instanceKlass"</span>); </span><br><span class="line">    instanceKlass* ik = (instanceKlass*) k_entry-&gt;klass_part(); </span><br><span class="line">    <span class="comment">// 确保对象所属类型已经经过初始化阶段 </span></span><br><span class="line">    <span class="keyword">if</span> ( ik-&gt;is_initialized() &amp;&amp; ik-&gt;can_be_fastpath_allocated() ) &#123; </span><br><span class="line">        <span class="comment">// 取对象长度 </span></span><br><span class="line">        size_t obj_size = ik-&gt;size_helper(); </span><br><span class="line">        oop result = NULL; </span><br><span class="line">        <span class="comment">// 记录是否需要将对象所有字段置零值 </span></span><br><span class="line">        <span class="keyword">bool</span> need_zero = !ZeroTLAB; </span><br><span class="line">        <span class="comment">// 是否在TLAB中分配对象 </span></span><br><span class="line">        <span class="keyword">if</span> (UseTLAB) &#123; </span><br><span class="line">            result = (oop) THREAD-&gt;tlab().allocate(obj_size); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (result == NULL) &#123; </span><br><span class="line">            need_zero = <span class="keyword">true</span>; </span><br><span class="line">            <span class="comment">// 直接在eden中分配对象 </span></span><br><span class="line">            retry: </span><br><span class="line">                HeapWord* compare_to = *Universe::heap()-&gt;top_addr(); </span><br><span class="line">                HeapWord* new_top = compare_to + obj_size; </span><br><span class="line">                <span class="comment">// cmpxchg是x86中的CAS指令，这里是一个C++方法，通过CAS方式分配空间，并发失败的话，转到retry中重试直至成功分配为止 </span></span><br><span class="line">                <span class="keyword">if</span> (new_top &lt;= *Universe::heap()-&gt;end_addr()) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (Atomic::cmpxchg_ptr(new_top, Universe::heap()-&gt;top_addr(), compare_to) != compare_to) &#123; </span><br><span class="line">                        <span class="keyword">goto</span> retry; </span><br><span class="line">                    &#125; </span><br><span class="line">                    result = (oop) compare_to; </span><br><span class="line">                &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (result != NULL) &#123; </span><br><span class="line">            <span class="comment">// 如果需要，为对象初始化零值 </span></span><br><span class="line">            <span class="keyword">if</span> (need_zero ) &#123; </span><br><span class="line">                HeapWord* to_zero = (HeapWord*) result + <span class="keyword">sizeof</span>(oopDesc) / oopSize; </span><br><span class="line">                obj_size -= <span class="keyword">sizeof</span>(oopDesc) / oopSize; </span><br><span class="line">                <span class="keyword">if</span> (obj_size &gt; <span class="number">0</span> ) &#123; </span><br><span class="line">                    <span class="built_in">memset</span>(to_zero, <span class="number">0</span>, obj_size * HeapWordSize); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 根据是否启用偏向锁，设置对象头信息 </span></span><br><span class="line">            <span class="keyword">if</span> (UseBiasedLocking) &#123; </span><br><span class="line">                result-&gt;set_mark(ik-&gt;prototype_header()); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                result-&gt;set_mark(markOopDesc::prototype()); </span><br><span class="line">            &#125; </span><br><span class="line">            result-&gt;set_klass_gap(<span class="number">0</span>); </span><br><span class="line">            result-&gt;set_klass(k_entry); </span><br><span class="line">            <span class="comment">// 将对象引用入栈，继续执行下一条指令 </span></span><br><span class="line">            SET_STACK_OBJECT(result, <span class="number">0</span>); </span><br><span class="line">            UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">3</span>, <span class="number">1</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</init></init></li>
</ul>
<h2 id="对象的内存布局">对象的内存布局</h2><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：<code>对象头（Header）</code>、<code>实例数据（Instance Data）</code>和<code>对齐填充（Padding）</code>。<br>HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。<br>| 存储内容      |    标志位 | 状态  |<br>| :———— | ————:| :—: |<br>| 对象哈希码、对象分代年龄| 01 |  未锁定   |<br>| 指向锁记录的指针|   00 |  轻量级锁定|<br>| 指向重量级锁的指针|    10 | 膨胀（重量级锁定）|<br>| 空，不需要记录信息|    11 | GC标记|<br>| 偏向线程ID、偏向时间戳、对象分代年龄|    01 | 可偏向|<br>表 HotSpot虚拟机对象头Mark Word<br>对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说查找对象的元数据信息并不一定要经过对象本身，这点我们在下一节讨论。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。<br>以下是HotSpot虚拟机markOop.cpp中的代码（注释）片段，它描述了32bits下MarkWord的存储状态：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bit-format of an object header (most significant first, big endian layout below): </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 32 bits: </span></span><br><span class="line"><span class="comment">// -------- </span></span><br><span class="line"><span class="comment">// hash:25 ------------&gt;| age:4 biased_lock:1 lock:2 (normal object) </span></span><br><span class="line"><span class="comment">// JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2 (biased object) </span></span><br><span class="line"><span class="comment">// size:32 ------------------------------------------&gt;| (CMS free block) </span></span><br><span class="line"><span class="comment">// PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br></pre></td></tr></table></figure></p>
<p>接下来实例数据部分是对象真正存储的有效信息，也既是我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。<br>第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头部分正好似8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<h2 id="对象的访问定位">对象的访问定位</h2><p>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范里面只规定了是一个指向对象的引用，并没有定义这个引用应该通过什么种方式去定位、访问到堆中的对象的具体位置，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用句柄和直接指针两种。</p>
<ul>
<li>如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。如图所示。<br><img src="http://duoinfo.sinaapp.com/pro/picofoschina/11.jpg" alt="通过句柄访问对象"></li>
<li>如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如图所示。<br><img src="http://duoinfo.sinaapp.com/pro/picofoschina/12.jpg" alt="通过直接指针访问对象"><br>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。<br>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项非常可观的执行成本。从上一部分讲解的对象内存布局可以看出，就虚拟机HotSpot而言，它是使用第二种方式进行对象访问，但在整个软件开发的范围来看，各种语言、框架中使用句柄来访问的情况也十分常见。<h1 id="OutOfMemoryError异常">OutOfMemoryError异常</h1>在java虚拟机中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OOM的可能。<h2 id="配置参数">配置参数</h2>IDE(Eclipse如下)<br><img src="http://duoinfo.sinaapp.com/pro/picofoschina/13.PNG" alt="配置参数"><h2 id="Java堆溢出">Java堆溢出</h2>代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;HeapOOM.OOMObject&gt;();</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>IDE下的错误：<br><img src="http://duoinfo.sinaapp.com/pro/picofoschina/15.PNG" alt="错误log"><br>命令行下：<br><img src="http://duoinfo.sinaapp.com/pro/picofoschina/14.PNG" alt="错误log"><br>可以通过Eclipse Memory analyzer（内存映像分析工具）进行分析。</p>
<h2 id="虚拟机栈和本地方法栈溢出">虚拟机栈和本地方法栈溢出</h2><p>关于虚拟机栈和本地方法栈，有下面的两种异常：</p>
<ul>
<li>StackOverFlowError异常</li>
<li>OutOfMemoryError异常<br>程序如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">		stackLength++;</span><br><span class="line">		stackLeak();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			oom.stackLeak();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable  e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Stack Length:"</span> + oom.stackLength);</span><br><span class="line">			<span class="keyword">throw</span> e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>运行的异常：<br><img src="http://duoinfo.sinaapp.com/pro/picofoschina/16.PNG" alt="错误log"><br>结果表明：在单线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverFlowError异常。</p>
<h2 id="方法区和运行时常量池溢出">方法区和运行时常量池溢出</h2><p><code>String.intern()</code>方法是一个Native方法，他的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。<br>代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			list.add(String.valueOf(i++).intern());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我的JDK版本是1.8的，运行未出现问题。（程序可能主要是为了说明运行时常量池属于方法区）<br>本部分告一段落。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/JVM/">JVM</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/JVM/">JVM</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://chenfuduo.me/2015/05/26/Java内存区域与内存溢出异常/" data-title="Java内存区域与内存溢出异常 | louis.chen" data-tsina="2338582935" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/05/27/垃圾收集器与内存分配策略/" title="垃圾收集器">
  <strong>上一篇：</strong><br/>
  <span>
  垃圾收集器</span>
</a>
</div>


<div class="next">
<a href="/2015/05/25/Boosting-the-performance-for-Gradle-in-your-Android-Projects/"  title="Boosting the performance for Gradle in your Android Projects">
 <strong>下一篇：</strong><br/> 
 <span>Boosting the performance for Gradle in your Android Projects
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/05/26/Java内存区域与内存溢出异常/" data-title="Java内存区域与内存溢出异常" data-url="http://chenfuduo.me/2015/05/26/Java内存区域与内存溢出异常/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#运行时数据区域"><span class="toc-number">1.</span> <span class="toc-text">运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#程序计数器"><span class="toc-number">1.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java虚拟机栈"><span class="toc-number">1.2.</span> <span class="toc-text">Java虚拟机栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#本地方法栈"><span class="toc-number">1.3.</span> <span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java堆"><span class="toc-number">1.4.</span> <span class="toc-text">Java堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区"><span class="toc-number">1.5.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运行时常量池"><span class="toc-number">1.6.</span> <span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#直接内存"><span class="toc-number">1.7.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HotSpot虚拟机对象探秘"><span class="toc-number">2.</span> <span class="toc-text">HotSpot虚拟机对象探秘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的创建"><span class="toc-number">2.1.</span> <span class="toc-text">对象的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的内存布局"><span class="toc-number">2.2.</span> <span class="toc-text">对象的内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的访问定位"><span class="toc-number">2.3.</span> <span class="toc-text">对象的访问定位</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OutOfMemoryError异常"><span class="toc-number">3.</span> <span class="toc-text">OutOfMemoryError异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#配置参数"><span class="toc-number">3.1.</span> <span class="toc-text">配置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java堆溢出"><span class="toc-number">3.2.</span> <span class="toc-text">Java堆溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机栈和本地方法栈溢出"><span class="toc-number">3.3.</span> <span class="toc-text">虚拟机栈和本地方法栈溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法区和运行时常量池溢出"><span class="toc-number">3.4.</span> <span class="toc-text">方法区和运行时常量池溢出</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/JVM/" title="JVM">JVM<sup>2</sup></a></li>
		  
		
		  
		
		  
			<li><a href="/categories/生活/" title="生活">生活<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/移动开发/" title="移动开发">移动开发<sup>14</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>18</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>18</sup></a></li>
			
		
			
				<li><a href="/tags/移动开发/" title="移动开发">移动开发<sup>14</sup></a></li>
			
		
			
				<li><a href="/tags/JVM/" title="JVM">JVM<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/生活/" title="生活">生活<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://www.vogella.com/tutorials/android.html" target="_blank" title="Vogella">Vogella</a>
            
          </li>
        
    </ul>
</div>

  <div class="weiboshow">
  <p class="asidetitle">新浪微博</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=2338582935&verifier=59b78413&dpc=1"></iframe>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> louis.chen,student of USTC,Focus on mobile develop. <br/>
			It is my amibition to make beautiful apps.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2338582935" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		<a href="https://github.com/leerduo" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="louis.chen">louis.chen</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          c.click();
        }
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"chenlouis"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F63c029dba1e367df2c8ffa39a309056a' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
