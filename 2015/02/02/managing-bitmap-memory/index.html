
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Managing Bitmap Memory | louis.chen</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="louis.chen">
    
    <meta name="description" content="In addition to the steps described in Caching Bitmaps, there are specific things you can do to facilitate garbage collection and bitmap reuse. The rec">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="louis.chen" title="louis.chen"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="louis.chen">louis.chen</a></h1>
				<h2 class="blog-motto">Mobile developers,experience extreme product.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">博客</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/02/02/managing-bitmap-memory/" title="Managing Bitmap Memory" itemprop="url">Managing Bitmap Memory</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://yoursite.com" title="louis.chen">louis.chen</a>
    </p>
  <p class="article-time">
    <time datetime="2015-02-02T02:42:42.000Z" itemprop="datePublished">2015-02-02</time>
    更新日期:<time datetime="2015-04-20T07:21:35.635Z" itemprop="dateModified">2015-04-20</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Manage_Memory_on_Android_2-3-3_and_Lower"><span class="toc-number">1.</span> <span class="toc-text">Manage Memory on Android 2.3.3 and Lower</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manage_Memory_on_Android_3-0_and_Higher"><span class="toc-number">2.</span> <span class="toc-text">Manage Memory on Android 3.0 and Higher</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Save_a_bitmap_for_later_use"><span class="toc-number">2.1.</span> <span class="toc-text">Save a bitmap for later use</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保存bitmap供以后使用(Save_a_bitmap_for_later_use)"><span class="toc-number">2.2.</span> <span class="toc-text">保存bitmap供以后使用(Save a bitmap for later use)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Use_an_existing_bitmap"><span class="toc-number">2.3.</span> <span class="toc-text">Use an existing bitmap</span></a></li></ol></li></ol>
		</div>
		
		<p>In addition to the steps described in <a href="file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/training/displaying-bitmaps/cache-bitmap.html" target="_blank" rel="external">Caching Bitmaps</a>, there are specific things you can do to facilitate garbage collection and bitmap reuse. The recommended strategy depends on which version(s) of Android you are targeting. The <a href="http://developer.android.com/downloads/samples/DisplayingBitmaps.zip" target="_blank" rel="external">DisplayingBitmaps</a> sample app included with this class shows you how to design your app to work efficiently across different versions of Android.</p>
<p>To set the stage for this lesson, here is how Android’s management of bitmap memory has evolved:</p>
<ul>
<li>On Android Android 2.2 (API level 8) and lower, when garbage collection occurs, your app’s threads get stopped. This causes a lag that can degrade performance. <strong>Android 2.3 adds concurrent garbage collection, which means that the memory is reclaimed soon after a bitmap is no longer referenced.</strong></li>
<li>On Android 2.3.3 (API level 10) and lower, the backing pixel data for a bitmap is stored in native memory. It is separate from the bitmap itself, which is stored in the Dalvik heap. The pixel data in native memory is not released in a predictable manner, potentially causing an application to briefly exceed its memory limits and crash. <strong>As of Android 3.0 (API level 11), the pixel data is stored on the Dalvik heap along with the associated bitmap.</strong><br>The following sections describe how to optimize bitmap memory management for different Android versions.</li>
</ul>
<p>译：</p>
<p>作为缓存Bitmaps的进一步延伸, 为了促进GC与bitmap的重用，你还有一些特定的事情可以做. 推荐的策略会根据Android的版本不同而有所差异. <a href="http://developer.android.com/downloads/samples/DisplayingBitmaps.zip" target="_blank" rel="external">DisplayingBitmaps</a>的示例程序会演示如何设计你的程序使得能够在不同的Android平台上高效的运行.</p>
<p>为了给这节课奠定基础，我们首先要知道Android管理bitmap memory的演变进程:</p>
<ul>
<li>在Android 2.2 (API level 8)以及之前, 当GC发生时, 你的应用的线程是会stopped的. 这导致了一个滞后，它会降低效率. <strong>在Android 2.3上，添加了并发GC的机制, 这意味着在一个bitmap不再被引用到之后，内存会被立即回收.</strong></li>
<li>在Android 2.3.3 (API level 10)以及之前, 一个bitmap的像素级数据是存放在native内存中的. 这些数据与bitmap本身是隔离的, bitmap本身是被存放在Dalvik heap中。在native内存中的pixel数据的释放是不可预测的，这意味着有可能导致一个程序容易超过它的内存限制并Crash。 <strong>自Android 3.0 (API Level 11)起, pixel数据则是与bitmap本身一起存放在dalvik heap中。</strong><br>下面会介绍如何在不同的Android版本上优化bitmap内存使用。</li>
</ul>
<h2 id="Manage_Memory_on_Android_2-3-3_and_Lower">Manage Memory on Android 2.3.3 and Lower</h2><hr>
<p>On Android 2.3.3 (API level 10) and lower, using <code>[recycle()](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/graphics/Bitmap.html#recycle())</code> is recommended. If you’re displaying large amounts of bitmap data in your app, you’re likely to run into <code>[OutOfMemoryError](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/java/lang/OutOfMemoryError.html)</code> errors. The<code>[recycle()](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/graphics/Bitmap.html#recycle())</code> method allows an app to reclaim memory as soon as possible.</p>
<p><strong>Caution:</strong> You should use <code>[recycle()](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/graphics/Bitmap.html#recycle())</code> only when you are sure that the bitmap is no longer being used. If you call <code>[recycle()](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/graphics/Bitmap.html#recycle())</code> and later attempt to draw the bitmap, you will get the error: <code>&quot;Canvas: trying to use a recycled bitmap&quot;</code>.</p>
<p>The following code snippet gives an example of calling <code>[recycle()](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/graphics/Bitmap.html#recycle())</code>. It uses reference counting (in the variables <code>mDisplayRefCount</code> and <code>mCacheRefCount</code>) to track whether a bitmap is currently being displayed or in the cache. The code recycles the bitmap when these conditions are met:</p>
<ul>
<li>The reference count for both <code>mDisplayRefCount</code> and <code>mCacheRefCount</code> is 0.</li>
<li>The bitmap is not <code>null</code>, and it hasn’t been recycled yet.<br>译：</li>
</ul>
<p>在Android 2.3.3 (API level 10) 以及更低版本上，推荐使用<a href="http://developer.android.com/reference/android/graphics/Bitmap.html#recycle(" target="_blank" rel="external">recycle()</a>). 如果在你的程序中显示了大量的bitmap数据，你很可能会遇到<a href="http://developer.android.com/reference/java/lang/OutOfMemoryError.html" target="_blank" rel="external">OutOfMemoryError</a>错误. <a href="http://developer.android.com/reference/android/graphics/Bitmap.html#recycle(" target="_blank" rel="external">recycle()</a>)方法可以使得程序尽快的释放内存.</p>
<blockquote>
<p><strong>Caution:</strong>只有你确保这个bitmap不再需要用到的时候才应该使用recycle(). 如果你执行recycle()，然后尝试绘制这个bitmap, 你将得到错误:<code>&quot;Canvas: trying to use a recycled bitmap&quot;</code>.<br>下面的代码片段演示了使用recycle()的例子. 它使用了引用计数的方法(<code>mDisplayRefCount</code> 与<code>mCacheRefCount</code>)来追踪一个bitmap目前是否有被显示或者是在缓存中. 当下面条件满足时回收bitmap:</p>
</blockquote>
<ul>
<li><code>mDisplayRefCount</code> 与 <code>mCacheRefCount</code> 的引用计数均为 0.</li>
<li>bitmap不为<code>null</code>, 并且它还没有被回收.<br>[java]private int mCacheRefCount = 0;<br>private int mDisplayRefCount = 0;<br>…<br>// Notify the drawable that the displayed state has changed.<br>// Keep a count to determine when the drawable is no longer displayed.<br>public void setIsDisplayed(boolean isDisplayed) {<br>synchronized (this) {<br>if (isDisplayed) {<br>mDisplayRefCount++;<br>mHasBeenDisplayed = true;<br>} else {<br>mDisplayRefCount—;<br>}<br>}<br>// Check to see if recycle() can be called.<br>checkState();<br>}</li>
</ul>
<p>// Notify the drawable that the cache state has changed.<br>// Keep a count to determine when the drawable is no longer being cached.<br>public void setIsCached(boolean isCached) {<br>synchronized (this) {<br>if (isCached) {<br>mCacheRefCount++;<br>} else {<br>mCacheRefCount—;<br>}<br>}<br>// Check to see if recycle() can be called.<br>checkState();<br>}</p>
<p>private synchronized void checkState() {<br>// If the drawable cache and display ref counts = 0, and this drawable<br>// has been displayed, then recycle.<br>if (mCacheRefCount &lt;= 0 &amp;&amp; mDisplayRefCount &lt;= 0 &amp;&amp; mHasBeenDisplayed<br>&amp;&amp; hasValidBitmap()) {<br>getBitmap().recycle();<br>}<br>}</p>
<p>private synchronized boolean hasValidBitmap() {<br>Bitmap bitmap = getBitmap();<br>return bitmap != null &amp;&amp; !bitmap.isRecycled();<br>}[/java]</p>
<h2 id="Manage_Memory_on_Android_3-0_and_Higher">Manage Memory on Android 3.0 and Higher</h2><hr>
<p>Android 3.0 (API level 11) introduces the <code>[BitmapFactory.Options.inBitmap](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/graphics/BitmapFactory.Options.html#inBitmap)</code> field. If this option is set, decode methods that take the <code>[Options](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/graphics/BitmapFactory.Options.html)</code> object will attempt to reuse an existing bitmap when loading content. This means that the bitmap’s memory is reused, resulting in improved performance, and removing both memory allocation and de-allocation. However, there are certain restrictions with how <code>[inBitmap](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/graphics/BitmapFactory.Options.html#inBitmap)</code> can be used. In particular, before Android 4.4 (API level 19), only equal sized bitmaps are supported. For details, please see the <code>[inBitmap](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/graphics/BitmapFactory.Options.html#inBitmap)</code> documentation.</p>
<h3 id="Save_a_bitmap_for_later_use">Save a bitmap for later use</h3><p>The following snippet demonstrates how an existing bitmap is stored for possible later use in the sample app. When an app is running on Android 3.0 or higher and a bitmap is evicted from the<code>[LruCache](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/util/LruCache.html)</code>, a soft reference to the bitmap is placed in a <code>[HashSet](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/java/util/HashSet.html)</code>, for possible reuse later with<code>[inBitmap](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/graphics/BitmapFactory.Options.html#inBitmap)</code>:</p>
<p>译：</p>
<p>在Android 3.0 (API Level 11) 引进了<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inBitmap" target="_blank" rel="external">BitmapFactory.Options.inBitmap</a>. 如果这个值被设置了，decode方法会在加载内容的时候去重用已经存在的bitmap. 这意味着bitmap的内存是被重新利用的，这样可以提升性能, 并且减少了内存的分配与回收。然而，使用<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inBitmap" target="_blank" rel="external">inBitmap</a>有一些限制。特别是在Android 4.4 (API level 19)之前，只支持同等大小的位图。详情请查看<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inBitmap" target="_blank" rel="external">inBitmap文档</a>.</p>
<h3 id="保存bitmap供以后使用(Save_a_bitmap_for_later_use)">保存bitmap供以后使用(Save a bitmap for later use)</h3><p>下面演示了一个已经存在的bitmap是如何被存放起来以便后续使用的. 当一个应用运行在Android 3.0或者更高的平台上并且bitmap从LruCache中移除时, bitmap的一个软引用会被存放在<a href="http://developer.android.com/reference/java/util/HashSet.html" target="_blank" rel="external">Hashset</a>中，这样便于之后可能被<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inBitmap" target="_blank" rel="external">inBitmap</a>重用:</p>
<p>[java]Set&lt;SoftReference&lt;Bitmap&gt;&gt; mReusableBitmaps;<br>private LruCache&lt;String, BitmapDrawable&gt; mMemoryCache;</p>
<p>// If you’re running on Honeycomb or newer, create a<br>// synchronized HashSet of references to reusable bitmaps.<br>if (Utils.hasHoneycomb()) {<br>mReusableBitmaps =<br>Collections.synchronizedSet(new HashSet&lt;SoftReference&lt;Bitmap&gt;&gt;());<br>}</p>
<p>mMemoryCache = new LruCache&lt;String, BitmapDrawable&gt;(mCacheParams.memCacheSize) {</p>
<p>// Notify the removed entry that is no longer being cached.<br>@Override<br>protected void entryRemoved(boolean evicted, String key,<br>BitmapDrawable oldValue, BitmapDrawable newValue) {<br>if (RecyclingBitmapDrawable.class.isInstance(oldValue)) {<br>// The removed entry is a recycling drawable, so notify it<br>// that it has been removed from the memory cache.<br>((RecyclingBitmapDrawable) oldValue).setIsCached(false);<br>} else {<br>// The removed entry is a standard BitmapDrawable.<br>if (Utils.hasHoneycomb()) {<br>// We’re running on Honeycomb or later, so add the bitmap<br>// to a SoftReference set for possible use with inBitmap later.<br>mReusableBitmaps.add<br>(new SoftReference&lt;Bitmap&gt;(oldValue.getBitmap()));<br>}<br>}<br>}<br>….<br>}[/java]</p>
<h3 id="Use_an_existing_bitmap">Use an existing bitmap</h3><p>In the running app, decoder methods check to see if there is an existing bitmap they can use. For example:</p>
<p>[java]public static Bitmap decodeSampledBitmapFromFile(String filename,<br>int reqWidth, int reqHeight, ImageCache cache) {</p>
<p>final BitmapFactory.Options options = new BitmapFactory.Options();<br>…<br>BitmapFactory.decodeFile(filename, options);<br>…</p>
<p>// If we’re running on Honeycomb or newer, try to use inBitmap.<br>if (Utils.hasHoneycomb()) {<br>addInBitmapOptions(options, cache);<br>}<br>…<br>return BitmapFactory.decodeFile(filename, options);<br>}[/java]<br>The next snippet shows the <code>addInBitmapOptions()</code> method that is called in the above snippet. It looks for an existing bitmap to set as the value for <code>[inBitmap](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/graphics/BitmapFactory.Options.html#inBitmap)</code>. Note that this method only sets a value for<code>[inBitmap](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/graphics/BitmapFactory.Options.html#inBitmap)</code> if it finds a suitable match (your code should never assume that a match will be found):<br>[java]private static void addInBitmapOptions(BitmapFactory.Options options,<br>ImageCache cache) {<br>// inBitmap only works with mutable bitmaps, so force the decoder to<br>// return mutable bitmaps.<br>options.inMutable = true;</p>
<p>if (cache != null) {<br>// Try to find a bitmap to use for inBitmap.<br>Bitmap inBitmap = cache.getBitmapFromReusableSet(options);</p>
<p>if (inBitmap != null) {<br>// If a suitable bitmap has been found, set it as the value of<br>// inBitmap.<br>options.inBitmap = inBitmap;<br>}<br>}<br>}</p>
<p>// This method iterates through the reusable bitmaps, looking for one<br>// to use for inBitmap:<br>protected Bitmap getBitmapFromReusableSet(BitmapFactory.Options options) {<br>Bitmap bitmap = null;</p>
<p>if (mReusableBitmaps != null &amp;&amp; !mReusableBitmaps.isEmpty()) {<br>synchronized (mReusableBitmaps) {<br>final Iterator&lt;SoftReference&lt;Bitmap&gt;&gt; iterator<br>= mReusableBitmaps.iterator();<br>Bitmap item;</p>
<p>while (iterator.hasNext()) {<br>item = iterator.next().get();</p>
<p>if (null != item &amp;&amp; item.isMutable()) {<br>// Check to see it the item can be used for inBitmap.<br>if (canUseForInBitmap(item, options)) {<br>bitmap = item;</p>
<p>// Remove from reusable set so it can’t be used again.<br>iterator.remove();<br>break;<br>}<br>} else {<br>// Remove from the set if the reference has been cleared.<br>iterator.remove();<br>}<br>}<br>}<br>}<br>return bitmap;<br>}[/java]</p>
<p>Finally, this method determines whether a candidate bitmap satisfies the size criteria to be used for <code>[inBitmap](file:///D:/Users/Administrator/AppData/Local/Android/sdk/docs/reference/android/graphics/BitmapFactory.Options.html#inBitmap)</code>:</p>
<p>[java]static boolean canUseForInBitmap(<br>Bitmap candidate, BitmapFactory.Options targetOptions) {</p>
<p>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {<br>// From Android 4.4 (KitKat) onward we can re-use if the byte size of<br>// the new bitmap is smaller than the reusable bitmap candidate<br>// allocation byte count.<br>int width = targetOptions.outWidth / targetOptions.inSampleSize;<br>int height = targetOptions.outHeight / targetOptions.inSampleSize;<br>int byteCount = width <em> height </em> getBytesPerPixel(candidate.getConfig());<br>return byteCount &lt;= candidate.getAllocationByteCount();<br>}</p>
<p>// On earlier versions, the dimensions must match exactly and the inSampleSize must be 1<br>return candidate.getWidth() == targetOptions.outWidth<br>&amp;&amp; candidate.getHeight() == targetOptions.outHeight<br>&amp;&amp; targetOptions.inSampleSize == 1;<br>}</p>
<p>/**</p>
<ul>
<li>A helper function to return the byte usage per pixel of a bitmap based on its configuration.<br>*/<br>static int getBytesPerPixel(Config config) {<br>if (config == Config.ARGB_8888) {<br>return 4;<br>} else if (config == Config.RGB_565) {<br>return 2;<br>} else if (config == Config.ARGB_4444) {<br>return 2;<br>} else if (config == Config.ALPHA_8) {<br>return 1;<br>}<br>return 1;<br>}[/java]</li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>
  
	</div>
		<footer class="article-footer clearfix">


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android开发/">Android开发</a>
</div>



<div class="article-share" id="share">

  <div data-url="http://yoursite.com/2015/02/02/managing-bitmap-memory/" data-title="Managing Bitmap Memory | louis.chen" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/02/02/displaying-bitmaps-in-your-ui/" title="Displaying Bitmaps in Your UI">
  <strong>PREVIOUS:</strong><br/>
  <span>
  Displaying Bitmaps in Your UI</span>
</a>
</div>


<div class="next">
<a href="/2015/02/02/caching-bitmaps/"  title="Caching Bitmaps">
 <strong>NEXT:</strong><br/> 
 <span>Caching Bitmaps
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Manage_Memory_on_Android_2-3-3_and_Lower"><span class="toc-number">1.</span> <span class="toc-text">Manage Memory on Android 2.3.3 and Lower</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manage_Memory_on_Android_3-0_and_Higher"><span class="toc-number">2.</span> <span class="toc-text">Manage Memory on Android 3.0 and Higher</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Save_a_bitmap_for_later_use"><span class="toc-number">2.1.</span> <span class="toc-text">Save a bitmap for later use</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#保存bitmap供以后使用(Save_a_bitmap_for_later_use)"><span class="toc-number">2.2.</span> <span class="toc-text">保存bitmap供以后使用(Save a bitmap for later use)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Use_an_existing_bitmap"><span class="toc-number">2.3.</span> <span class="toc-text">Use an existing bitmap</span></a></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
			<li><a href="/categories/Android开发/" title="Android开发">Android开发<sup>21</sup></a></li>
		
			<li><a href="/categories/Android开源框架/" title="Android开源框架">Android开源框架<sup>4</sup></a></li>
		
			<li><a href="/categories/Android开发/Dandelion/" title="Dandelion">Dandelion<sup>1</sup></a></li>
		
			<li><a href="/categories/Java/" title="Java">Java<sup>1</sup></a></li>
		
			<li><a href="/categories/Android开发/Training文档/" title="Training文档">Training文档<sup>9</sup></a></li>
		
			<li><a href="/categories/Training文档/" title="Training文档">Training文档<sup>9</sup></a></li>
		
			<li><a href="/categories/blog/" title="blog">blog<sup>1</sup></a></li>
		
			<li><a href="/categories/未分类/" title="未分类">未分类<sup>0</sup></a></li>
		
			<li><a href="/categories/自定义控件/" title="自定义控件">自定义控件<sup>4</sup></a></li>
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/博客/" title="博客">博客<sup>1</sup></a></li>
		
			<li><a href="/tags/文章/" title="文章">文章<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="null" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> louis.chen,student of USTC,Focus on mobile develop. <br/>
			It is my amibition to develop beautiful app.</p>
	</section>
	 
	<div class="social-font clearfix">
		
		<a href="http://weibo.com/2338582935" target="_blank" title="weibo"></a>
		
		
		
		<a href="https://github.com/leerduo" target="_blank" title="github"></a>
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2015 
		
		<a href="http://yoursite.com" target="_blank" title="louis.chen">louis.chen</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"null"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
